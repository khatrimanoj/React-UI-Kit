{"ast":null,"code":"var _jsxFileName = \"/home/mindbox/Documents/manoj/nexus/src/components/Carousel/CenterCarousel.js\";\nimport React, { useState, useEffect, useRef } from 'react';\nimport './Carousel.css';\n/* Default Properties */\n\nconst IMG_WIDTH = 300;\nconst IMG_HEIGHT = 300;\nconst parentPad = 0;\nconst VISIBLEIMAGES = 3;\nconst DURATION = 750;\n\nconst Carousel = props => {\n  const {\n    imgList = [],\n    img_width = IMG_WIDTH,\n    img_height = IMG_HEIGHT,\n    visibleImages = VISIBLEIMAGES,\n    duration = DURATION,\n    autoNext = false,\n    timeForNext = 5000\n  } = props;\n  /* Hooks Declarations Start*/\n\n  const [currFirstImg, setCurrFirstImg] = useState(0); // The Current Middle Element/Primary element of our carousel\n\n  const [actualFirst, setActualFirst] = useState(''); // The Clicked Image when it is not the Immediate Next or Immediate Previous Image\n\n  const [visibleItemsProps, setVisibleItemsProps] = useState({\n    order: [],\n    styles: {}\n  }); // Set Styles and ordering to Images currently visible\n\n  const currMiddleImgRef = useRef(0); // Reference for the image that is in the middle\n\n  const intervalRef = useRef(0); // Reference to interval so that it can be removed from within/ before initiating new interval\n\n  const imgDifference = useRef(1); // The difference between the middle image and the image that is clicked by user to view next\n\n  const durationRef = useRef(duration); // Animation Duration, it should be changed when the image cicked is not immediate next/prev\n\n  /* Hooks Declarations End*/\n\n  const parentHeight = img_height + 2 * parentPad; // To avoid overlap with Carousel Component's siblings, since all images are absolutely positioned\n\n  const parentWidth = img_width * 3; // To have thrice the width of an individual image\n\n  const elementsInLeft = Math.ceil(visibleImages / 2); // Floor is done to also include middle image along with other images to its left.\n\n  const elementsInRight = visibleImages - elementsInLeft;\n\n  const constructVisibleItemsProps = () => {\n    const visibleItemsProps = {}; // To store config for items that are visibile in the carousel\n\n    visibleItemsProps.order = [];\n    let curr_center = currFirstImg; // Storing the Current Middle element in focus\n\n    let timesToIterate = 0; // To iterate through all visible number of images.\n\n    let zIndex = -elementsInRight; // We start from left to right and Zindex has to keep on increasing till middle then has to reduce.\n\n    let xTranslate = img_width; // To move the element with respect to x axis\n\n    let zTranslate = 0; // To reduce image size for images apart from center\n\n    let opacity = 1;\n    const division = img_width * (1.66 / elementsInLeft); // Specifies the length that next image has to move away from with resoect to current image (1.6 times the current image)\n\n    let opacityDivider = 0.7 / elementsInRight; // minimum opacity should be 0.3 (1-0.7)\n\n    let rightEltCount = elementsInRight;\n    let leftEltCount = elementsInLeft; // including middle element\n\n    let curr_center_copy = curr_center;\n\n    while (timesToIterate < visibleImages) {\n      const styles = {};\n      let currImgIndex;\n      let currImgIndexOnRight = true; // Tells if in this iteration the currently iterated image lies left to the middle image or not\n      // To set properties for elements in right side\n\n      if (timesToIterate < elementsInRight) {\n        const nextIndex = curr_center - rightEltCount;\n        currImgIndex = nextIndex > -1 ? nextIndex : imgList.length - Math.abs(nextIndex); // Gives the rightmost elemnt in first iteration and then the subsequent elements down the iteration\n\n        opacity = 1 - opacityDivider * rightEltCount; // To assign lowest opacity to last element and increaing it till we come to middle\n\n        zTranslate = -division * rightEltCount; // To increase the size of the images subsequently from last to middle\n\n        xTranslate = img_width - division * rightEltCount; // X coordinate position\n\n        rightEltCount--;\n      } else {\n        // To set properties for elements in center and to left of it. All props behaves similar to right\n        currImgIndexOnRight = false;\n        currImgIndex = curr_center_copy;\n\n        if (curr_center_copy + 1 >= imgList.length) {\n          // to maintain cyclic carousel\n          curr_center_copy = 0;\n        } else {\n          curr_center_copy++;\n        }\n\n        opacity = 1 - opacityDivider * Math.abs(leftEltCount - (timesToIterate + 1));\n        zTranslate = -division * Math.abs(leftEltCount - (timesToIterate + 1));\n        xTranslate = img_width + division * Math.abs(leftEltCount - (timesToIterate + 1));\n      } // Assigning above calculated values to 'styles' object\n\n\n      styles.transform = 'translateX(' + xTranslate + 'px) translateZ(' + zTranslate + 'px)';\n      styles.opacity = opacity;\n      styles.zIndex = currImgIndexOnRight ? zIndex++ : zIndex--; // To reduce zIndex while going through left elements\n\n      visibleItemsProps.order.push(currImgIndex); // Push the current image number in the orders array\n\n      visibleItemsProps[currImgIndex] = {\n        styles\n      }; // pushing all previously created styles\n\n      timesToIterate++;\n    }\n\n    durationRef.current = actualFirst === '' ? duration : duration / imgDifference.current; // duration will be user given if he clicks next image or we divide the duration by number of images skipped\n\n    setVisibleItemsProps(visibleItemsProps); // setting state for visible items\n  };\n\n  const changeCenter = ({\n    event,\n    index,\n    large_url\n  }) => {\n    // Checking if the clicked item is immediately next/prev item.Because to induce a carousel effect we need to make the images move in sequence.\n    // But that is not possible, when the user clicks out of sequence(Eg: image 4 from image 1).So here, the order breaks and we cannot \n    // apply our sequential handling logic to it. If we do the 4th image comes into view from the back but the \"cycling effect\"\n    // of scrolling through images 2 and 3 would have been missed.\n    const currFirstImgIndex = visibleItemsProps.order.indexOf(currFirstImg);\n    const prevIndex = visibleItemsProps.order[currFirstImgIndex - 1];\n    const nextIndex = visibleItemsProps.order[currFirstImgIndex + 1];\n\n    if (index !== currFirstImg) {\n      if (index === prevIndex || index === nextIndex) {\n        // if immediate first/next image\n        setCurrFirstImg(index);\n      } else {\n        const val = currFirstImgIndex - visibleItemsProps.order.indexOf(index);\n        imgDifference.current = Math.abs(val); // Gives the number of images we have to cycle through, so we can provide equal part of total duration to all images.\n\n        setActualFirst(index);\n        cycleToNextImage(index);\n      }\n    } else {\n      window.open(large_url); // Can have a callback in props and execute it on click.\n    }\n  }; // To show the subsequent image based on if the user has clicked on the right side or on the left side of the middle image\n\n\n  const cycleToNextImage = actual => {\n    if (visibleItemsProps.order.indexOf(currMiddleImgRef.current) > visibleItemsProps.order.indexOf(actual)) {\n      // Right side image click\n      currMiddleImgRef.current = currMiddleImgRef.current - 1 > -1 ? currMiddleImgRef.current - 1 : imgList.length - 1; // Right side image click\n\n      setCurrFirstImg(currMiddleImgRef.current);\n    } else {\n      // Left side image click\n      currMiddleImgRef.current = currMiddleImgRef.current + 1 < imgList.length ? currMiddleImgRef.current + 1 : 0; // Conditions to handle cycle\n\n      setCurrFirstImg(currMiddleImgRef.current);\n    }\n  }; // Hook fires on evey change to actualFirst value. actualFirst is set when there is out of order click, so we have to handle it through timeinterval\n  // so that we can allow all intermediate images to do some animation in the meantime, to avoid the cycling look jerky.\n\n\n  useEffect(() => {\n    clearInterval(intervalRef.current);\n\n    if (actualFirst !== '') {\n      intervalRef.current = setInterval(() => {\n        if (actualFirst !== '' && actualFirst !== currMiddleImgRef.current) {\n          // If the currentimage in middle is not actually clicked image then gotoNext image\n          cycleToNextImage(actualFirst);\n        } else if (actualFirst !== '' && actualFirst === currMiddleImgRef.current) {\n          setActualFirst('');\n          imgDifference.current = 1;\n          clearInterval(intervalRef.current); // If actual clicked and middle image are same we are all set to clear intervals, as they are unnecessary now\n        }\n      }, durationRef.current - 100); // Introduced an advance of 100ms to begin bringing nextimage to middle before the previous one settles down else it looks jerky\n    }\n  }, [actualFirst]); // ✅ OK (our effect only uses `someProp`)\n\n  useEffect(() => {\n    constructVisibleItemsProps(); // This constructs all css properties to the elements in visibility\n\n    currMiddleImgRef.current = currFirstImg; // Need to set it here as well so while accessing inside interval it will have the latest value\n  }, [currFirstImg]);\n  useEffect(() => {\n    if (autoNext) {\n      setInterval(() => {\n        const nextImg = currMiddleImgRef.current + 1 < imgList.length ? currMiddleImgRef.current + 1 : 0;\n        setCurrFirstImg(nextImg);\n      }, timeForNext);\n    }\n  }, []);\n\n  const loadCarousel = () => {\n    return /*#__PURE__*/React.createElement(\"ul\", {\n      className: \"carouselWrapper\",\n      style: {\n        height: parentHeight + 'px',\n        width: parentWidth + 'px',\n        padding: parentPad + 'px',\n        perspective: '500px'\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 145,\n        columnNumber: 7\n      }\n    }, imgList.map(({\n      large_url,\n      url,\n      id\n    }, index) => {\n      const dn = visibleItemsProps.order.indexOf(index) === -1; // To not to show images that are out of visibility scope\n\n      const styles = visibleItemsProps[index] ? visibleItemsProps[index].styles : {};\n      return /*#__PURE__*/React.createElement(\"li\", {\n        key: id,\n        className: 'imgWrap ' + (dn ? 'dn' : ''),\n        style: { ...styles,\n          position: 'rela',\n          transition: `all ${durationRef.current}ms linear `\n        },\n        onClick: e => {\n          changeCenter({\n            e,\n            index,\n            large_url\n          });\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 151,\n          columnNumber: 13\n        }\n      }, /*#__PURE__*/React.createElement(\"img\", {\n        src: url,\n        alt: 'img_' + id,\n        width: img_width,\n        height: img_height,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 152,\n          columnNumber: 15\n        }\n      }));\n    }));\n  };\n\n  return /*#__PURE__*/React.createElement(React.Fragment, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 162,\n      columnNumber: 5\n    }\n  }, loadCarousel());\n};\n\nexport default Carousel;","map":{"version":3,"sources":["/home/mindbox/Documents/manoj/nexus/src/components/Carousel/CenterCarousel.js"],"names":["React","useState","useEffect","useRef","IMG_WIDTH","IMG_HEIGHT","parentPad","VISIBLEIMAGES","DURATION","Carousel","props","imgList","img_width","img_height","visibleImages","duration","autoNext","timeForNext","currFirstImg","setCurrFirstImg","actualFirst","setActualFirst","visibleItemsProps","setVisibleItemsProps","order","styles","currMiddleImgRef","intervalRef","imgDifference","durationRef","parentHeight","parentWidth","elementsInLeft","Math","ceil","elementsInRight","constructVisibleItemsProps","curr_center","timesToIterate","zIndex","xTranslate","zTranslate","opacity","division","opacityDivider","rightEltCount","leftEltCount","curr_center_copy","currImgIndex","currImgIndexOnRight","nextIndex","length","abs","transform","push","current","changeCenter","event","index","large_url","currFirstImgIndex","indexOf","prevIndex","val","cycleToNextImage","window","open","actual","clearInterval","setInterval","nextImg","loadCarousel","height","width","padding","perspective","map","url","id","dn","position","transition","e"],"mappings":"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","sourcesContent":["import React, {useState, useEffect, useRef} from 'react';\nimport './Carousel.css';\n\n/* Default Properties */\nconst IMG_WIDTH = 300;\nconst IMG_HEIGHT = 300;\nconst parentPad = 0;\nconst VISIBLEIMAGES = 3;\nconst DURATION = 750;\nconst Carousel = (props) => {\n  const {imgList = [], img_width = IMG_WIDTH, img_height = IMG_HEIGHT, visibleImages = VISIBLEIMAGES, duration = DURATION, autoNext = false, timeForNext = 5000} = props;\n  /* Hooks Declarations Start*/\n  const [currFirstImg, setCurrFirstImg] = useState(0);  // The Current Middle Element/Primary element of our carousel\n  const [actualFirst, setActualFirst] = useState('');   // The Clicked Image when it is not the Immediate Next or Immediate Previous Image\n  const [visibleItemsProps, setVisibleItemsProps] = useState({ order: [], styles: {}}); // Set Styles and ordering to Images currently visible\n  const currMiddleImgRef = useRef(0);  // Reference for the image that is in the middle\n  const intervalRef = useRef(0);  // Reference to interval so that it can be removed from within/ before initiating new interval\n  const imgDifference = useRef(1); // The difference between the middle image and the image that is clicked by user to view next\n  const durationRef = useRef(duration); // Animation Duration, it should be changed when the image cicked is not immediate next/prev\n  /* Hooks Declarations End*/\n  const parentHeight = img_height + 2 * parentPad;  // To avoid overlap with Carousel Component's siblings, since all images are absolutely positioned\n  const parentWidth = img_width * 3;  // To have thrice the width of an individual image\n  const elementsInLeft = Math.ceil(visibleImages / 2);  // Floor is done to also include middle image along with other images to its left.\n  const elementsInRight = visibleImages - elementsInLeft;\n\n  const constructVisibleItemsProps = () => {\n    const visibleItemsProps = {}; // To store config for items that are visibile in the carousel\n    visibleItemsProps.order = [];\n    let curr_center = currFirstImg; // Storing the Current Middle element in focus\n    let timesToIterate = 0; // To iterate through all visible number of images.\n    let zIndex = - elementsInRight; // We start from left to right and Zindex has to keep on increasing till middle then has to reduce.\n    let xTranslate = img_width; // To move the element with respect to x axis\n    let zTranslate = 0; // To reduce image size for images apart from center\n    let opacity = 1;\n    const division = (img_width * (1.66 / elementsInLeft)); // Specifies the length that next image has to move away from with resoect to current image (1.6 times the current image)\n    let opacityDivider = (0.7 / elementsInRight); // minimum opacity should be 0.3 (1-0.7)\n    let rightEltCount = elementsInRight;\n    let leftEltCount = elementsInLeft; // including middle element\n    let curr_center_copy = curr_center;\n  \n    while(timesToIterate < visibleImages ) {\n      const styles = {};\n      let currImgIndex;\n      let currImgIndexOnRight = true; // Tells if in this iteration the currently iterated image lies left to the middle image or not\n      // To set properties for elements in right side\n      if (timesToIterate < elementsInRight) {\n        const nextIndex = curr_center - (rightEltCount);\n        currImgIndex = nextIndex > -1 ? nextIndex : imgList.length - Math.abs(nextIndex); // Gives the rightmost elemnt in first iteration and then the subsequent elements down the iteration\n        opacity = 1 - (opacityDivider * rightEltCount); // To assign lowest opacity to last element and increaing it till we come to middle\n        zTranslate =  -division * rightEltCount;  // To increase the size of the images subsequently from last to middle\n        xTranslate = img_width - (division * rightEltCount);  // X coordinate position\n        rightEltCount--;\n      } else {  // To set properties for elements in center and to left of it. All props behaves similar to right\n        currImgIndexOnRight = false;\n        currImgIndex = curr_center_copy;  \n        if (curr_center_copy + 1 >= imgList.length) { // to maintain cyclic carousel\n          curr_center_copy = 0;\n        } else {\n          curr_center_copy++;\n        }\n        opacity = 1 - (opacityDivider * Math.abs(leftEltCount - (timesToIterate + 1)));\n        zTranslate =  - division * Math.abs(leftEltCount - (timesToIterate + 1));\n        xTranslate = img_width + division * Math.abs(leftEltCount - (timesToIterate + 1));\n      }\n      // Assigning above calculated values to 'styles' object\n      styles.transform =  'translateX(' + xTranslate + 'px) translateZ(' +  zTranslate + 'px)';\n      styles.opacity = opacity;\n      styles.zIndex = currImgIndexOnRight ? zIndex++ : zIndex --; // To reduce zIndex while going through left elements\n      visibleItemsProps.order.push(currImgIndex); // Push the current image number in the orders array\n      visibleItemsProps[currImgIndex] = { styles }; // pushing all previously created styles\n      timesToIterate++;\n    }\n    durationRef.current = actualFirst === '' ? duration : ((duration / imgDifference.current)); // duration will be user given if he clicks next image or we divide the duration by number of images skipped\n    setVisibleItemsProps(visibleItemsProps); // setting state for visible items\n  }\n\n\n  const changeCenter = ({event, index, large_url }) => {\n    // Checking if the clicked item is immediately next/prev item.Because to induce a carousel effect we need to make the images move in sequence.\n    // But that is not possible, when the user clicks out of sequence(Eg: image 4 from image 1).So here, the order breaks and we cannot \n    // apply our sequential handling logic to it. If we do the 4th image comes into view from the back but the \"cycling effect\"\n    // of scrolling through images 2 and 3 would have been missed.\n    const currFirstImgIndex = visibleItemsProps.order.indexOf(currFirstImg);\n    const prevIndex = visibleItemsProps.order[currFirstImgIndex - 1];\n    const nextIndex = visibleItemsProps.order[currFirstImgIndex + 1];\n    if (index !== currFirstImg) {\n      if (index === prevIndex || index === nextIndex) { // if immediate first/next image\n        setCurrFirstImg(index);\n      } else {\n        const val = currFirstImgIndex - visibleItemsProps.order.indexOf(index);\n        imgDifference.current = Math.abs(val);  // Gives the number of images we have to cycle through, so we can provide equal part of total duration to all images.\n        setActualFirst(index);\n        cycleToNextImage(index);\n      }\n    } else {\n      window.open(large_url); // Can have a callback in props and execute it on click.\n    }\n  }\n\n  // To show the subsequent image based on if the user has clicked on the right side or on the left side of the middle image\n  const cycleToNextImage = (actual) => {\n    if (visibleItemsProps.order.indexOf(currMiddleImgRef.current) > visibleItemsProps.order.indexOf(actual)) {  // Right side image click\n      currMiddleImgRef.current = currMiddleImgRef.current - 1 > -1 ? currMiddleImgRef.current - 1 : imgList.length - 1; // Right side image click\n      setCurrFirstImg(currMiddleImgRef.current);\n    } else {  // Left side image click\n      currMiddleImgRef.current = (currMiddleImgRef.current + 1) < imgList.length ?  (currMiddleImgRef.current + 1) : 0; // Conditions to handle cycle\n      setCurrFirstImg(currMiddleImgRef.current);\n    }\n  }\n\n  // Hook fires on evey change to actualFirst value. actualFirst is set when there is out of order click, so we have to handle it through timeinterval\n  // so that we can allow all intermediate images to do some animation in the meantime, to avoid the cycling look jerky.\n  useEffect(() => {\n    clearInterval(intervalRef.current);\n    if (actualFirst !== '') {\n      intervalRef.current = setInterval(() => {\n        if (actualFirst !== '' && actualFirst !== currMiddleImgRef.current) { // If the currentimage in middle is not actually clicked image then gotoNext image\n          cycleToNextImage(actualFirst);\n        } else if (actualFirst !== '' && actualFirst === currMiddleImgRef.current){\n          setActualFirst('');\n          imgDifference.current = 1;\n          clearInterval(intervalRef.current); // If actual clicked and middle image are same we are all set to clear intervals, as they are unnecessary now\n        }\n      }, durationRef.current - 100);  // Introduced an advance of 100ms to begin bringing nextimage to middle before the previous one settles down else it looks jerky\n    }\n  }, [actualFirst]);// ✅ OK (our effect only uses `someProp`)\n\n\n  useEffect(() => {\n    constructVisibleItemsProps(); // This constructs all css properties to the elements in visibility\n    currMiddleImgRef.current = currFirstImg;  // Need to set it here as well so while accessing inside interval it will have the latest value\n  }, [currFirstImg]);\n\n  useEffect(() => {\n    if (autoNext) {\n      setInterval(() => {\n        const nextImg = currMiddleImgRef.current + 1 < imgList.length ?  currMiddleImgRef.current + 1 : 0;\n        setCurrFirstImg(nextImg);\n      }, timeForNext);\n    }\n  }, []);\n\n  const loadCarousel = () => {\n    return (\n      <ul className=\"carouselWrapper\" style={{ height: parentHeight + 'px', width:  parentWidth + 'px', padding: parentPad + 'px', perspective: '500px'}}>\n      {\n        imgList.map(({large_url, url, id}, index) => {\n          const dn = visibleItemsProps.order.indexOf(index) === -1; // To not to show images that are out of visibility scope\n          const styles = visibleItemsProps[index] ? visibleItemsProps[index].styles: {};\n          return (\n            <li key={id} className={'imgWrap ' + (dn ? 'dn': '')} style={{...styles, position: 'rela', transition: `all ${durationRef.current}ms linear `}} onClick={(e) => { changeCenter({e, index, large_url})} }>\n              <img src={url} alt={'img_' + id } width={img_width} height={img_height}/>\n            </li>\n          )\n        })\n      }\n      </ul>\n    );\n  };\n\n  return (\n    <React.Fragment>\n      {loadCarousel()}\n    </React.Fragment>\n  );\n}\nexport default Carousel;\n"]},"metadata":{},"sourceType":"module"}