{"ast":null,"code":"// import React from 'react'\n// import PropTypes from 'prop-types'\n// import Index from './Index'\n// const styles = {\n//   wrapper: {\n//     width: '100%',\n//     height: '100%',\n//     position: 'relative'\n//   },\n//   frame: {\n//     // width: '100%',\n//     height: '100%',\n//     position: 'absolute'\n//   }\n// }\n// class Carousel extends React.Component {\n//   constructor (props) {\n//     super(props)\n//     this.state = {\n//       frames: [].concat(props.frames || props.children || []),\n//       current: 0\n//     }\n//     this.mounted = false\n//     this.debounceTimeoutId = null\n//     this.onTouchStart = this.onTouchStart.bind(this)\n//     this.onTouchMove = this.onTouchMove.bind(this)\n//     this.onTouchEnd = this.onTouchEnd.bind(this)\n//     this.onResize = this.onResize.bind(this)\n//     this.autoSlide = this.autoSlide.bind(this)\n//     this.prev = this.prev.bind(this)\n//     this.next = this.next.bind(this)\n//     if (props.loop === false && props.auto) {\n//       console.warn('[re-carousel] Auto-slide only works in loop mode.')\n//     }\n//   }\n//   componentDidMount () {\n//     this.mounted = true\n//     this.prepareAutoSlide()\n//     this.hideFrames()\n//     this.refs.wrapper.addEventListener('touchmove', this.onTouchMove, {capture: true})\n//     this.refs.wrapper.addEventListener('touchend', this.onTouchEnd, {capture: true})\n//     window.addEventListener('resize', this.onResize);\n//   }\n//   componentWillUnmount () {\n//     this.mounted = false\n//     this.clearAutoTimeout()\n//     this.refs.wrapper.removeEventListener('touchmove', this.onTouchMove, {capture: true})\n//     this.refs.wrapper.removeEventListener('touchend', this.onTouchEnd, {capture: true})\n//     window.removeEventListener('resize', this.onResize);\n//   }\n//   componentDidUpdate(_, prevState) {\n//     if (this.state.frames.length && this.state.frames.length !== prevState.frames.length) {\n//       // reset to default state\n//       this.hideFrames()\n//       this.prepareAutoSlide()\n//     }\n//   }\n//   static getDerivedStateFromProps(nextProps, prevState) {\n//     const frames = [].concat(nextProps.frames || nextProps.children || [])\n//     const nextState = { frames }\n//     if (frames.length && frames.length !== prevState.frames.length) {\n//       nextState.current = 0\n//     }\n//     return nextState\n//   }\n//   hideFrames () {\n//     for (let i = 1; i < this.state.frames.length; i++) {\n//       this.refs['f' + i].style.opacity = 0\n//     }\n//   }\n//   onResize() {\n//     clearTimeout(this.debounceTimeoutId);\n//     this.debounceTimeoutId = setTimeout(() => {\n//       this.updateFrameSize(() => {\n//         this.prepareSiblingFrames();\n//       });\n//     }, 25);\n//   }\n//   onTouchStart (e) {\n//     if (this.state.total < 2) return\n//     // e.preventDefault()\n//     this.clearAutoTimeout()\n//     this.updateFrameSize()\n//     this.prepareSiblingFrames()\n//     const { pageX, pageY } = (e.touches && e.touches[0]) || e\n//     this.setState({\n//       startX: pageX,\n//       startY: pageY,\n//       deltaX: 0,\n//       deltaY: 0\n//     })\n//     this.refs.wrapper.addEventListener('mousemove', this.onTouchMove, {capture: true})\n//     this.refs.wrapper.addEventListener('mouseup', this.onTouchEnd, {capture: true})\n//     this.refs.wrapper.addEventListener('mouseleave', this.onTouchEnd, {capture: true})\n//   }\n//   onTouchMove (e) {\n//     if (e.touches && e.touches.length > 1) return\n//     this.clearAutoTimeout()\n//     const { pageX, pageY } = (e.touches && e.touches[0]) || e\n//     let deltaX = pageX - this.state.startX\n//     let deltaY = pageY - this.state.startY\n//     this.setState({\n//       deltaX: deltaX,\n//       deltaY: deltaY\n//     })\n//     if (this.props.axis === 'x' && Math.abs(deltaX) > Math.abs(deltaY)) {\n//       e.preventDefault()\n//       e.stopPropagation()\n//     }\n//     if (this.props.axis === 'y' && Math.abs(deltaY) > Math.abs(deltaX)) {\n//       e.preventDefault()\n//       e.stopPropagation()\n//     }\n//     // when reach frames edge in non-loop mode, reduce drag effect.\n//     if (!this.props.loop) {\n//       if (this.state.current === this.state.frames.length - 1) {\n//         deltaX < 0 && (deltaX /= 3)\n//         deltaY < 0 && (deltaY /= 3)\n//       }\n//       if (this.state.current === 0) {\n//         deltaX > 0 && (deltaX /= 3)\n//         deltaY > 0 && (deltaY /= 3)\n//       }\n//     }\n//     this.moveFramesBy(deltaX, deltaY)\n//   }\n//   onTouchEnd () {\n//     const direction = this.decideEndPosition()\n//     direction && this.transitFramesTowards(direction)\n//     // cleanup\n//     this.refs.wrapper.removeEventListener('mousemove', this.onTouchMove, {capture: true})\n//     this.refs.wrapper.removeEventListener('mouseup', this.onTouchEnd, {capture: true})\n//     this.refs.wrapper.removeEventListener('mouseleave', this.onTouchEnd, {capture: true})\n//     setTimeout(() => this.prepareAutoSlide(), this.props.duration)\n//   }\n//   decideEndPosition () {\n//     const { deltaX = 0, deltaY = 0, current, frames } = this.state\n//     const { axis, loop, minMove } = this.props\n//     switch (axis) {\n//       case 'x':\n//         if (loop === false) {\n//           if (current === 0 && deltaX > 0) return 'origin'\n//           if (current === frames.length - 1 && deltaX < 0) return 'origin'\n//         }\n//         if (Math.abs(deltaX) < minMove) return 'origin'\n//         return deltaX > 0 ? 'right' : 'left'\n//       case 'y':\n//         if (loop === false) {\n//           if (current === 0 && deltaY > 0) return 'origin'\n//           if (current === frames.length - 1 && deltaY < 0) return 'origin'\n//         }\n//         if (Math.abs(deltaY) < minMove) return 'origin'\n//         return deltaY > 0 ? 'down' : 'up'\n//       default:\n//     }\n//   }\n//   moveFramesBy (deltaX, deltaY) {\n//     const { prev, current, next } = this.state.movingFrames\n//     const { frameWidth, frameHeight } = this.state\n//     switch (this.props.axis) {\n//       case 'x':\n//         translateXY(current, deltaX, 0)\n//         if (deltaX < 0) {\n//           translateXY(next, deltaX + frameWidth, 0)\n//         } else {\n//           translateXY(prev, deltaX - frameWidth, 0)\n//         }\n//         break\n//       case 'y':\n//         translateXY(current, 0, deltaY)\n//         if (deltaY < 0) {\n//           translateXY(next, 0, deltaY + frameHeight)\n//         } else {\n//           translateXY(prev, 0, deltaY - frameHeight)\n//         }\n//         break\n//       default:\n//     }\n//   }\n//   prepareAutoSlide () {\n//     if (this.state.frames.length < 2) return\n//     this.clearAutoTimeout()\n//     this.updateFrameSize(() => {\n//       this.prepareSiblingFrames()\n//     })\n//     // auto slide only avalible in loop mode\n//     if (this.mounted && this.props.loop && this.props.auto) {\n//       const slideTimeoutID = setTimeout(this.autoSlide, this.props.interval)\n//       this.setState({ slider: slideTimeoutID })\n//     }\n//   }\n//   // auto slide to 'next' or 'prev'\n//   autoSlide (rel) {\n//     this.clearAutoTimeout()\n//     switch (rel) {\n//       case 'prev':\n//         this.transitFramesTowards(this.props.axis === 'x' ? 'right' : 'down')\n//         break\n//       case 'next':\n//       default:\n//         this.transitFramesTowards(this.props.axis === 'x' ? 'left' : 'up')\n//     }\n//     // prepare next move after animation\n//     setTimeout(() => this.prepareAutoSlide(), this.props.duration)\n//   }\n//   next () {\n//     const { current, frames } = this.state\n//     if (!this.props.loop && current === frames.length - 1) return false\n//     this.autoSlide('next')\n//   }\n//   prev () {\n//     if (!this.props.loop && this.state.current === 0) return false\n//     const { prev, next } = this.state.movingFrames\n//     if (prev === next) {\n//       // Reprepare start position of prev frame\n//       // (it was positioned as \"next\" frame)\n//       if (this.props.axis === 'x') {\n//         translateXY(prev, -this.state.frameWidth, 0, 0)\n//       } else {\n//         translateXY(prev, 0, -this.state.frameHeight, 0)\n//       }\n//       prev.getClientRects() // trigger layout\n//     }\n//     this.autoSlide('prev')\n//   }\n//   clearAutoTimeout () {\n//     clearTimeout(this.state.slider)\n//   }\n//   updateFrameSize (cb) {\n//     const { width, height } = window.getComputedStyle(this.refs.wrapper)\n//     this.setState({\n//       frameWidth: parseFloat(width.split('%')[0]),\n//       frameHeight: parseFloat(height.split('%')[0])\n//     }, cb)\n//   }\n//   getSiblingFrames () {\n//     return {\n//       current: this.refs['f' + this.getFrameId()],\n//       prev: this.refs['f' + this.getFrameId('prev')],\n//       next: this.refs['f' + this.getFrameId('next')]\n//     }\n//   }\n//   prepareSiblingFrames () {\n//     const siblings = this.getSiblingFrames()\n//     if (!this.props.loop) {\n//       this.state.current === 0 && (siblings.prev = undefined)\n//       this.state.current === this.state.frames.length - 1 && (siblings.next = undefined)\n//     }\n//     this.setState({ movingFrames: siblings })\n//     // prepare frames position\n//     translateXY(siblings.current, 0, 0)\n//     if (this.props.axis === 'x') {\n//       translateXY(siblings.prev, -this.state.frameWidth, 0)\n//       translateXY(siblings.next, this.state.frameWidth, 0)\n//     } else {\n//       translateXY(siblings.prev, 0, -this.state.frameHeight)\n//       translateXY(siblings.next, 0, this.state.frameHeight)\n//     }\n//     return siblings\n//   }\n//   getFrameId (pos) {\n//     const { frames, current } = this.state\n//     const total = frames.length\n//     switch (pos) {\n//       case 'prev':\n//         return (current - 1 + total) % total\n//       case 'next':\n//         return (current + 1) % total\n//       default:\n//         return current\n//     }\n//   }\n//   transitFramesTowards (direction) {\n//     const { prev, current, next } = this.state.movingFrames\n//     const { duration, axis, onTransitionEnd } = this.props\n//     let newCurrentId = this.state.current\n//     switch (direction) {\n//       case 'up':\n//         translateXY(current, 0, -this.state.frameHeight, duration)\n//         translateXY(next, 0, 0, duration)\n//         newCurrentId = this.getFrameId('next')\n//         break\n//       case 'down':\n//         translateXY(current, 0, this.state.frameHeight, duration)\n//         translateXY(prev, 0, 0, duration)\n//         newCurrentId = this.getFrameId('prev')\n//         break\n//       case 'left':\n//         translateXY(current, -this.state.frameWidth, 0, duration)\n//         translateXY(next, 0, 0, duration)\n//         newCurrentId = this.getFrameId('next')\n//         break\n//       case 'right':\n//         translateXY(current, this.state.frameWidth, 0, duration)\n//         translateXY(prev, 0, 0, duration)\n//         newCurrentId = this.getFrameId('prev')\n//         break\n//       default: // back to origin\n//         translateXY(current, 0, 0, duration)\n//         if (axis === 'x') {\n//           translateXY(prev, -this.state.frameWidth, 0, duration)\n//           translateXY(next, this.state.frameWidth, 0, duration)\n//         } else if (axis === 'y') {\n//           translateXY(prev, 0, -this.state.frameHeight, duration)\n//           translateXY(next, 0, this.state.frameHeight, duration)\n//         }\n//     }\n//     onTransitionEnd && setTimeout(() => onTransitionEnd(this.getSiblingFrames()), duration)\n//     this.setState({ current: newCurrentId })\n//   }\n//   // debugFrames () {\n//   //   console.log('>>> DEBUG-FRAMES: current', this.state.current)\n//   //   const len = this.state.frames.length\n//   //   for (let i = 0; i < len; ++i) {\n//   //     const ref = this.refs['f' + i]\n//   //     console.info(ref.innerText.trim(), ref.style.transform)\n//   //   }\n//   // }\n//   render () {\n//     const { frames, current } = this.state\n//     const { widgets, axis, loop, auto, interval } = this.props\n//     const wrapperStyle = objectAssign(styles.wrapper, this.props.style)\n//     return (\n//       <div style={wrapperStyle}>\n//         <div\n//           ref='wrapper'\n//           style={objectAssign({overflow: 'hidden'}, wrapperStyle)}\n//           onTouchStart={this.onTouchStart}\n//           className={this.props.className}\n//           onMouseDown={this.onTouchStart} >\n//           {\n//             frames.map((frame, i) => {\n//               const frameStyle = objectAssign({zIndex: 99 - i}, styles.frame)\n//               return <div ref={'f' + i} key={i} style={frameStyle} className={`${current === i ? 'current slide' : 'slide'}`}>{frame}</div>\n//             })\n//           }\n//           { this.props.frames && this.props.children }\n//         </div>\n//         {\n//           widgets && [].concat(widgets).map((Widget, i) => (\n//             <Widget\n//               key={i}\n//               index={current}\n//               total={frames.length}\n//               prevHandler={this.prev}\n//               nextHandler={this.next}\n//               axis={axis} loop={loop} auto={auto} interval={interval} />\n//           ))\n//         }\n//       </div>\n//     )\n//   }\n// }\n// Carousel.propTypes = {\n//   axis: PropTypes.oneOf(['x', 'y']),\n//   auto: PropTypes.bool,\n//   loop: PropTypes.bool,\n//   interval: PropTypes.number,\n//   duration: PropTypes.number,\n//   widgets: PropTypes.arrayOf(PropTypes.func),\n//   frames: PropTypes.arrayOf(PropTypes.element),\n//   style: PropTypes.object,\n//   minMove: PropTypes.number,\n//   onTransitionEnd: PropTypes.func\n// }\n// Carousel.defaultProps = {\n//   axis: 'x',\n//   auto: false,\n//   loop: false,\n//   interval: 5000,\n//   duration: 300,\n//   minMove: 42\n// }\n// function translateXY (el, x, y, duration = 0) {\n//   if (!el) return\n//   el.style.opacity = '1'\n//   // animation\n//   el.style.transitionDuration = duration + 'ms'\n//   el.style.webkitTransitionDuration = duration + 'ms'\n//   el.currentItem = `translate(${x}px, ${y}px)`\n//   el.style.transform = `translate(${x}px, ${y}px)`\n//   el.style.webkitTransform = `translate(${x}px, ${y}px) translateZ(0)`\n// }\n// function objectAssign (target) {\n//   var output = Object(target)\n//   for (var index = 1; index < arguments.length; index++) {\n//     var source = arguments[index]\n//     if (source !== undefined && source !== null) {\n//       for (var nextKey in source) {\n//         if (source.hasOwnProperty(nextKey)) {\n//           output[nextKey] = source[nextKey]\n//         }\n//       }\n//     }\n//   }\n//   return output\n// }\n// export default Carousel","map":{"version":3,"sources":["/home/mindbox/Documents/manoj/nexus/src/components/Carousel/Carousel.js"],"names":[],"mappings":"AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA","sourcesContent":["// import React from 'react'\n// import PropTypes from 'prop-types'\n// import Index from './Index'\n\n// const styles = {\n//   wrapper: {\n//     width: '100%',\n//     height: '100%',\n//     position: 'relative'\n//   },\n//   frame: {\n//     // width: '100%',\n//     height: '100%',\n//     position: 'absolute'\n//   }\n// }\n\n// class Carousel extends React.Component {\n//   constructor (props) {\n//     super(props)\n\n//     this.state = {\n//       frames: [].concat(props.frames || props.children || []),\n//       current: 0\n//     }\n\n//     this.mounted = false\n//     this.debounceTimeoutId = null\n//     this.onTouchStart = this.onTouchStart.bind(this)\n//     this.onTouchMove = this.onTouchMove.bind(this)\n//     this.onTouchEnd = this.onTouchEnd.bind(this)\n//     this.onResize = this.onResize.bind(this)\n//     this.autoSlide = this.autoSlide.bind(this)\n//     this.prev = this.prev.bind(this)\n//     this.next = this.next.bind(this)\n\n//     if (props.loop === false && props.auto) {\n//       console.warn('[re-carousel] Auto-slide only works in loop mode.')\n//     }\n//   }\n\n//   componentDidMount () {\n//     this.mounted = true\n//     this.prepareAutoSlide()\n//     this.hideFrames()\n\n//     this.refs.wrapper.addEventListener('touchmove', this.onTouchMove, {capture: true})\n//     this.refs.wrapper.addEventListener('touchend', this.onTouchEnd, {capture: true})\n//     window.addEventListener('resize', this.onResize);\n//   }\n\n//   componentWillUnmount () {\n//     this.mounted = false\n//     this.clearAutoTimeout()\n\n//     this.refs.wrapper.removeEventListener('touchmove', this.onTouchMove, {capture: true})\n//     this.refs.wrapper.removeEventListener('touchend', this.onTouchEnd, {capture: true})\n//     window.removeEventListener('resize', this.onResize);\n//   }\n\n//   componentDidUpdate(_, prevState) {\n//     if (this.state.frames.length && this.state.frames.length !== prevState.frames.length) {\n//       // reset to default state\n//       this.hideFrames()\n//       this.prepareAutoSlide()\n//     }\n//   }\n\n//   static getDerivedStateFromProps(nextProps, prevState) {\n//     const frames = [].concat(nextProps.frames || nextProps.children || [])\n//     const nextState = { frames }\n//     if (frames.length && frames.length !== prevState.frames.length) {\n//       nextState.current = 0\n//     }\n//     return nextState\n//   }\n\n//   hideFrames () {\n//     for (let i = 1; i < this.state.frames.length; i++) {\n//       this.refs['f' + i].style.opacity = 0\n//     }\n//   }\n\n//   onResize() {\n//     clearTimeout(this.debounceTimeoutId);\n//     this.debounceTimeoutId = setTimeout(() => {\n//       this.updateFrameSize(() => {\n//         this.prepareSiblingFrames();\n//       });\n//     }, 25);\n//   }\n\n//   onTouchStart (e) {\n//     if (this.state.total < 2) return\n//     // e.preventDefault()\n\n//     this.clearAutoTimeout()\n//     this.updateFrameSize()\n//     this.prepareSiblingFrames()\n\n//     const { pageX, pageY } = (e.touches && e.touches[0]) || e\n//     this.setState({\n//       startX: pageX,\n//       startY: pageY,\n//       deltaX: 0,\n//       deltaY: 0\n//     })\n\n//     this.refs.wrapper.addEventListener('mousemove', this.onTouchMove, {capture: true})\n//     this.refs.wrapper.addEventListener('mouseup', this.onTouchEnd, {capture: true})\n//     this.refs.wrapper.addEventListener('mouseleave', this.onTouchEnd, {capture: true})\n//   }\n\n//   onTouchMove (e) {\n//     if (e.touches && e.touches.length > 1) return\n//     this.clearAutoTimeout()\n\n//     const { pageX, pageY } = (e.touches && e.touches[0]) || e\n//     let deltaX = pageX - this.state.startX\n//     let deltaY = pageY - this.state.startY\n//     this.setState({\n//       deltaX: deltaX,\n//       deltaY: deltaY\n//     })\n\n//     if (this.props.axis === 'x' && Math.abs(deltaX) > Math.abs(deltaY)) {\n//       e.preventDefault()\n//       e.stopPropagation()\n//     }\n//     if (this.props.axis === 'y' && Math.abs(deltaY) > Math.abs(deltaX)) {\n//       e.preventDefault()\n//       e.stopPropagation()\n//     }\n\n//     // when reach frames edge in non-loop mode, reduce drag effect.\n//     if (!this.props.loop) {\n//       if (this.state.current === this.state.frames.length - 1) {\n//         deltaX < 0 && (deltaX /= 3)\n//         deltaY < 0 && (deltaY /= 3)\n//       }\n//       if (this.state.current === 0) {\n//         deltaX > 0 && (deltaX /= 3)\n//         deltaY > 0 && (deltaY /= 3)\n//       }\n//     }\n\n//     this.moveFramesBy(deltaX, deltaY)\n//   }\n\n//   onTouchEnd () {\n//     const direction = this.decideEndPosition()\n//     direction && this.transitFramesTowards(direction)\n\n//     // cleanup\n//     this.refs.wrapper.removeEventListener('mousemove', this.onTouchMove, {capture: true})\n//     this.refs.wrapper.removeEventListener('mouseup', this.onTouchEnd, {capture: true})\n//     this.refs.wrapper.removeEventListener('mouseleave', this.onTouchEnd, {capture: true})\n\n//     setTimeout(() => this.prepareAutoSlide(), this.props.duration)\n//   }\n\n//   decideEndPosition () {\n//     const { deltaX = 0, deltaY = 0, current, frames } = this.state\n//     const { axis, loop, minMove } = this.props\n\n//     switch (axis) {\n//       case 'x':\n//         if (loop === false) {\n//           if (current === 0 && deltaX > 0) return 'origin'\n//           if (current === frames.length - 1 && deltaX < 0) return 'origin'\n//         }\n//         if (Math.abs(deltaX) < minMove) return 'origin'\n//         return deltaX > 0 ? 'right' : 'left'\n//       case 'y':\n//         if (loop === false) {\n//           if (current === 0 && deltaY > 0) return 'origin'\n//           if (current === frames.length - 1 && deltaY < 0) return 'origin'\n//         }\n//         if (Math.abs(deltaY) < minMove) return 'origin'\n//         return deltaY > 0 ? 'down' : 'up'\n//       default:\n//     }\n//   }\n\n//   moveFramesBy (deltaX, deltaY) {\n//     const { prev, current, next } = this.state.movingFrames\n//     const { frameWidth, frameHeight } = this.state\n\n//     switch (this.props.axis) {\n//       case 'x':\n//         translateXY(current, deltaX, 0)\n//         if (deltaX < 0) {\n//           translateXY(next, deltaX + frameWidth, 0)\n//         } else {\n//           translateXY(prev, deltaX - frameWidth, 0)\n//         }\n//         break\n//       case 'y':\n//         translateXY(current, 0, deltaY)\n//         if (deltaY < 0) {\n//           translateXY(next, 0, deltaY + frameHeight)\n//         } else {\n//           translateXY(prev, 0, deltaY - frameHeight)\n//         }\n//         break\n//       default:\n//     }\n//   }\n\n//   prepareAutoSlide () {\n//     if (this.state.frames.length < 2) return\n\n//     this.clearAutoTimeout()\n//     this.updateFrameSize(() => {\n//       this.prepareSiblingFrames()\n//     })\n\n//     // auto slide only avalible in loop mode\n//     if (this.mounted && this.props.loop && this.props.auto) {\n//       const slideTimeoutID = setTimeout(this.autoSlide, this.props.interval)\n//       this.setState({ slider: slideTimeoutID })\n//     }\n//   }\n\n//   // auto slide to 'next' or 'prev'\n//   autoSlide (rel) {\n//     this.clearAutoTimeout()\n\n//     switch (rel) {\n//       case 'prev':\n//         this.transitFramesTowards(this.props.axis === 'x' ? 'right' : 'down')\n//         break\n//       case 'next':\n//       default:\n//         this.transitFramesTowards(this.props.axis === 'x' ? 'left' : 'up')\n//     }\n\n//     // prepare next move after animation\n//     setTimeout(() => this.prepareAutoSlide(), this.props.duration)\n//   }\n\n//   next () {\n//     const { current, frames } = this.state\n//     if (!this.props.loop && current === frames.length - 1) return false\n//     this.autoSlide('next')\n//   }\n\n//   prev () {\n//     if (!this.props.loop && this.state.current === 0) return false\n//     const { prev, next } = this.state.movingFrames\n\n//     if (prev === next) {\n//       // Reprepare start position of prev frame\n//       // (it was positioned as \"next\" frame)\n//       if (this.props.axis === 'x') {\n//         translateXY(prev, -this.state.frameWidth, 0, 0)\n//       } else {\n//         translateXY(prev, 0, -this.state.frameHeight, 0)\n//       }\n//       prev.getClientRects() // trigger layout\n//     }\n\n//     this.autoSlide('prev')\n//   }\n\n//   clearAutoTimeout () {\n//     clearTimeout(this.state.slider)\n//   }\n\n//   updateFrameSize (cb) {\n//     const { width, height } = window.getComputedStyle(this.refs.wrapper)\n//     this.setState({\n//       frameWidth: parseFloat(width.split('%')[0]),\n//       frameHeight: parseFloat(height.split('%')[0])\n//     }, cb)\n//   }\n\n//   getSiblingFrames () {\n//     return {\n//       current: this.refs['f' + this.getFrameId()],\n//       prev: this.refs['f' + this.getFrameId('prev')],\n//       next: this.refs['f' + this.getFrameId('next')]\n//     }\n//   }\n\n//   prepareSiblingFrames () {\n//     const siblings = this.getSiblingFrames()\n\n//     if (!this.props.loop) {\n//       this.state.current === 0 && (siblings.prev = undefined)\n//       this.state.current === this.state.frames.length - 1 && (siblings.next = undefined)\n//     }\n\n//     this.setState({ movingFrames: siblings })\n\n//     // prepare frames position\n//     translateXY(siblings.current, 0, 0)\n//     if (this.props.axis === 'x') {\n//       translateXY(siblings.prev, -this.state.frameWidth, 0)\n//       translateXY(siblings.next, this.state.frameWidth, 0)\n//     } else {\n//       translateXY(siblings.prev, 0, -this.state.frameHeight)\n//       translateXY(siblings.next, 0, this.state.frameHeight)\n//     }\n\n//     return siblings\n//   }\n\n//   getFrameId (pos) {\n//     const { frames, current } = this.state\n//     const total = frames.length\n//     switch (pos) {\n//       case 'prev':\n//         return (current - 1 + total) % total\n//       case 'next':\n//         return (current + 1) % total\n//       default:\n//         return current\n//     }\n//   }\n\n//   transitFramesTowards (direction) {\n//     const { prev, current, next } = this.state.movingFrames\n//     const { duration, axis, onTransitionEnd } = this.props\n\n//     let newCurrentId = this.state.current\n//     switch (direction) {\n//       case 'up':\n//         translateXY(current, 0, -this.state.frameHeight, duration)\n//         translateXY(next, 0, 0, duration)\n//         newCurrentId = this.getFrameId('next')\n//         break\n//       case 'down':\n//         translateXY(current, 0, this.state.frameHeight, duration)\n//         translateXY(prev, 0, 0, duration)\n//         newCurrentId = this.getFrameId('prev')\n//         break\n//       case 'left':\n//         translateXY(current, -this.state.frameWidth, 0, duration)\n//         translateXY(next, 0, 0, duration)\n//         newCurrentId = this.getFrameId('next')\n//         break\n//       case 'right':\n//         translateXY(current, this.state.frameWidth, 0, duration)\n//         translateXY(prev, 0, 0, duration)\n//         newCurrentId = this.getFrameId('prev')\n//         break\n//       default: // back to origin\n//         translateXY(current, 0, 0, duration)\n//         if (axis === 'x') {\n//           translateXY(prev, -this.state.frameWidth, 0, duration)\n//           translateXY(next, this.state.frameWidth, 0, duration)\n//         } else if (axis === 'y') {\n//           translateXY(prev, 0, -this.state.frameHeight, duration)\n//           translateXY(next, 0, this.state.frameHeight, duration)\n//         }\n//     }\n\n//     onTransitionEnd && setTimeout(() => onTransitionEnd(this.getSiblingFrames()), duration)\n\n//     this.setState({ current: newCurrentId })\n//   }\n\n//   // debugFrames () {\n//   //   console.log('>>> DEBUG-FRAMES: current', this.state.current)\n//   //   const len = this.state.frames.length\n//   //   for (let i = 0; i < len; ++i) {\n//   //     const ref = this.refs['f' + i]\n//   //     console.info(ref.innerText.trim(), ref.style.transform)\n//   //   }\n//   // }\n\n//   render () {\n//     const { frames, current } = this.state\n//     const { widgets, axis, loop, auto, interval } = this.props\n//     const wrapperStyle = objectAssign(styles.wrapper, this.props.style)\n\n//     return (\n//       <div style={wrapperStyle}>\n//         <div\n//           ref='wrapper'\n//           style={objectAssign({overflow: 'hidden'}, wrapperStyle)}\n//           onTouchStart={this.onTouchStart}\n//           className={this.props.className}\n//           onMouseDown={this.onTouchStart} >\n//           {\n//             frames.map((frame, i) => {\n//               const frameStyle = objectAssign({zIndex: 99 - i}, styles.frame)\n//               return <div ref={'f' + i} key={i} style={frameStyle} className={`${current === i ? 'current slide' : 'slide'}`}>{frame}</div>\n//             })\n//           }\n//           { this.props.frames && this.props.children }\n//         </div>\n//         {\n//           widgets && [].concat(widgets).map((Widget, i) => (\n//             <Widget\n//               key={i}\n//               index={current}\n//               total={frames.length}\n//               prevHandler={this.prev}\n//               nextHandler={this.next}\n//               axis={axis} loop={loop} auto={auto} interval={interval} />\n//           ))\n//         }\n//       </div>\n//     )\n//   }\n// }\n\n// Carousel.propTypes = {\n//   axis: PropTypes.oneOf(['x', 'y']),\n//   auto: PropTypes.bool,\n//   loop: PropTypes.bool,\n//   interval: PropTypes.number,\n//   duration: PropTypes.number,\n//   widgets: PropTypes.arrayOf(PropTypes.func),\n//   frames: PropTypes.arrayOf(PropTypes.element),\n//   style: PropTypes.object,\n//   minMove: PropTypes.number,\n//   onTransitionEnd: PropTypes.func\n// }\n\n// Carousel.defaultProps = {\n//   axis: 'x',\n//   auto: false,\n//   loop: false,\n//   interval: 5000,\n//   duration: 300,\n//   minMove: 42\n// }\n\n// function translateXY (el, x, y, duration = 0) {\n//   if (!el) return\n\n//   el.style.opacity = '1'\n\n//   // animation\n//   el.style.transitionDuration = duration + 'ms'\n//   el.style.webkitTransitionDuration = duration + 'ms'\n//   el.currentItem = `translate(${x}px, ${y}px)`\n//   el.style.transform = `translate(${x}px, ${y}px)`\n//   el.style.webkitTransform = `translate(${x}px, ${y}px) translateZ(0)`\n// }\n\n// function objectAssign (target) {\n//   var output = Object(target)\n//   for (var index = 1; index < arguments.length; index++) {\n//     var source = arguments[index]\n//     if (source !== undefined && source !== null) {\n//       for (var nextKey in source) {\n//         if (source.hasOwnProperty(nextKey)) {\n//           output[nextKey] = source[nextKey]\n//         }\n//       }\n//     }\n//   }\n//   return output\n// }\n\n// export default Carousel"]},"metadata":{},"sourceType":"module"}