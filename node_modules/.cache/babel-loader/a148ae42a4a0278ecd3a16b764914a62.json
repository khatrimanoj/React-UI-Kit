{"ast":null,"code":"var _jsxFileName = \"/home/mindbox/Documents/manoj/nexus/src/components/Carousel/Carousel.js\";\n\n/* eslint-disable react/no-unused-prop-types */\n// we disable propTypes usage checking as we use getProp function\nimport React, { Component } from 'react';\nimport throttle from 'lodash/throttle';\nimport isNil from 'lodash/isNil';\nimport has from 'lodash/has';\nimport concat from 'lodash/concat';\nimport times from 'lodash/times';\nimport PropTypes from 'prop-types';\nimport classnames from 'classnames';\nimport config from './Config';\nimport CarouselItem from './CarouselItem';\nimport Dots from './CarouselDots';\nimport './Carousel.css';\nimport './Arrows.css';\n\nclass Carousel extends Component {\n  constructor(_props) {\n    super(_props);\n\n    this.getCurrentValue = () => this.props.infinite ? this.props.value : this.clamp(this.props.value);\n\n    this.getNeededAdditionalClones = () => Math.ceil((this.getCurrentValue() - this.state.infiniteTransitionFrom) / this.getChildren().length);\n\n    this.getAdditionalClonesLeft = () => {\n      const additionalClones = this.getNeededAdditionalClones();\n      return additionalClones < 0 ? -additionalClones : 0;\n    };\n\n    this.getAdditionalClonesRight = () => {\n      const additionalClones = this.getNeededAdditionalClones();\n      return additionalClones > 0 ? additionalClones : 0;\n    };\n\n    this.getClonesLeft = () => config.numberOfInfiniteClones + this.getAdditionalClonesLeft();\n\n    this.getClonesRight = () => config.numberOfInfiniteClones + this.getAdditionalClonesRight();\n\n    this.getAdditionalClonesOffset = () => -this.getChildren().length * this.getCarouselElementWidth() * this.getAdditionalClonesLeft();\n\n    this.getProp = (propName, customProps = null) => {\n      const props = customProps || this.props;\n      let activeBreakpoint = null;\n\n      if (props.breakpoints) {\n        const windowWidth = this.state.windowWidth;\n        const resolutions = Object.keys(props.breakpoints);\n        resolutions.forEach(resolutionString => {\n          const resolution = parseInt(resolutionString);\n\n          if (windowWidth <= resolution) {\n            if (!activeBreakpoint || activeBreakpoint > resolution) {\n              activeBreakpoint = resolution;\n            }\n          }\n        });\n      }\n\n      if (activeBreakpoint) {\n        if (has(props.breakpoints[activeBreakpoint], propName)) {\n          return props.breakpoints[activeBreakpoint][propName];\n        }\n      }\n\n      return props[propName];\n    };\n\n    this.checkIfValueChanged = prevProps => {\n      const currentValue = this.getProp('infinite') ? this.props.value : this.clamp(this.props.value);\n      const prevValue = this.getProp('infinite') ? prevProps.value : this.clamp(prevProps.value);\n      return currentValue !== prevValue;\n    };\n\n    this.resetInterval = () => {\n      if (this.interval) {\n        clearInterval(this.interval);\n      }\n\n      const autoPlay = this.getProp('autoPlay');\n\n      if (!isNil(autoPlay)) {\n        this.interval = setInterval(() => {\n          if (!document.hidden && !this.state.isAutoPlayStopped) {\n            this.nextSlide();\n          }\n        }, autoPlay);\n      }\n    };\n\n    this.getChildren = () => {\n      if (!this.props.children) {\n        if (this.props.slides) {\n          return this.props.slides;\n        }\n\n        return [];\n      }\n\n      if (Array.isArray(this.props.children)) {\n        return this.props.children;\n      }\n\n      return [this.props.children];\n    };\n\n    this.getActiveSlideIndex = () => this.getProp('infinite') ? this.getCurrentSlideIndex() + this.getClonesLeft() * this.getChildren().length : this.getCurrentSlideIndex();\n\n    this.getTargetMod = (customValue = null) => {\n      const value = isNil(customValue) ? this.getCurrentValue() : customValue;\n      const length = this.getChildren().length;\n      let targetSlide;\n\n      if (value >= 0) {\n        targetSlide = value % length;\n      } else {\n        targetSlide = (length - Math.abs(value % length)) % length;\n      }\n\n      return targetSlide;\n    };\n\n    this.getTargetSlide = () => {\n      if (!isNil(this.state.infiniteTransitionFrom)) {\n        const mod = this.getTargetMod(this.state.infiniteTransitionFrom);\n        const value = this.getCurrentValue();\n        return mod + (value - this.state.infiniteTransitionFrom);\n      }\n\n      return this.getTargetMod();\n    };\n\n    this.onMouseDown = (e, index) => {\n      e.preventDefault();\n      e.stopPropagation();\n      const {\n        pageX\n      } = e;\n      this.setState(() => ({\n        clicked: index,\n        dragStart: pageX\n      }));\n    };\n\n    this.onMouseMove = e => {\n      const {\n        pageX\n      } = e;\n\n      if (this.state.dragStart !== null) {\n        this.setState(previousState => ({\n          dragOffset: this.getProp('rtl') ? previousState.dragStart - pageX : pageX - previousState.dragStart\n        }));\n      }\n    };\n\n    this.onTouchStart = (e, index) => {\n      const {\n        changedTouches\n      } = e;\n      this.setState(() => ({\n        clicked: index,\n        dragStart: changedTouches[0].pageX\n      }));\n    };\n\n    this.onMouseUpTouchEnd = e => {\n      if (this.state.dragStart !== null) {\n        e.preventDefault();\n\n        if (this.getProp('draggable') && Math.abs(this.state.dragOffset) > config.clickDragThreshold) {\n          this.changeSlide(this.getNearestSlideIndex());\n        } else if (this.getProp('clickToChange')) {\n          this.changeSlide(this.getProp('infinite') ? this.getCurrentValue() + this.state.clicked - this.getActiveSlideIndex() : this.state.clicked);\n        }\n\n        this.setState(() => ({\n          clicked: null,\n          dragOffset: 0,\n          dragStart: null,\n          transitionEnabled: true\n        }));\n      }\n    };\n\n    this.onTransitionEnd = () => {\n      const infinite = this.getProp('infinite');\n      this.setState(() => ({\n        transitionEnabled: !infinite,\n        infiniteTransitionFrom: infinite ? this.getCurrentValue() : null\n      }));\n    };\n\n    this.onMouseEnter = () => {\n      this.setState(() => ({\n        isAutoPlayStopped: true\n      }));\n    };\n\n    this.onMouseLeave = () => {\n      this.setState(() => ({\n        isAutoPlayStopped: false\n      }));\n      this.resetInterval();\n    };\n\n    this.simulateEvent = e => {\n      const touch = e.changedTouches[0];\n      const {\n        screenX,\n        screenY,\n        clientX,\n        clientY\n      } = touch;\n      const touchEventMap = {\n        touchstart: 'mousedown',\n        touchmove: 'mousemove',\n        touchend: 'mouseup'\n      };\n      const simulatedEvent = new MouseEvent(touchEventMap[e.type], {\n        bubbles: true,\n        cancelable: true,\n        view: window,\n        detail: 1,\n        screenX,\n        screenY,\n        clientX,\n        clientY\n      });\n      touch.target.dispatchEvent(simulatedEvent);\n    };\n\n    this.clamp = value => {\n      const maxValue = this.getChildren().length - 1;\n\n      if (value > maxValue) {\n        return maxValue;\n      }\n\n      if (value < 0) {\n        return 0;\n      }\n\n      return value;\n    };\n\n    this.changeSlide = value => this.props.onChange(this.getProp('infinite') ? value : this.clamp(value));\n\n    this.nextSlide = () => this.changeSlide(this.getCurrentValue() + this.getProp('slidesPerScroll'));\n\n    this.prevSlide = () => this.changeSlide(this.getCurrentValue() - this.getProp('slidesPerScroll'));\n\n    this.getNearestSlideIndex = () => {\n      let slideIndexOffset = 0;\n\n      if (this.getProp('keepDirectionWhenDragging')) {\n        if (this.state.dragOffset > 0) {\n          slideIndexOffset = -Math.ceil(this.state.dragOffset / this.getCarouselElementWidth());\n        } else {\n          slideIndexOffset = -Math.floor(this.state.dragOffset / this.getCarouselElementWidth());\n        }\n      } else {\n        slideIndexOffset = -Math.round(this.state.dragOffset / this.getCarouselElementWidth());\n      }\n\n      return this.getCurrentValue() + slideIndexOffset;\n    };\n\n    this.getCurrentSlideIndex = () => {\n      if (this.getProp('infinite')) {\n        return this.getTargetSlide();\n      }\n\n      return this.clamp(this.getCurrentValue());\n    };\n\n    this.getCarouselElementWidth = () => this.props.itemWidth || this.state.carouselWidth / this.getProp('slidesPerPage');\n\n    this.getTransformOffset = () => {\n      const elementWidthWithOffset = this.getCarouselElementWidth() + this.getProp('offset');\n      const additionalOffset = this.getProp('centered') ? this.state.carouselWidth / 2 - elementWidthWithOffset / 2 : 0;\n      const dragOffset = this.getProp('draggable') ? this.state.dragOffset : 0;\n      const currentValue = this.getActiveSlideIndex();\n      const additionalClonesOffset = this.getAdditionalClonesOffset();\n      return dragOffset - currentValue * elementWidthWithOffset + additionalOffset - additionalClonesOffset;\n    };\n\n    this.renderCarouselItems = () => {\n      const isRTL = this.getProp('rtl');\n      const transformOffset = this.getTransformOffset();\n      const children = this.getChildren();\n      const numberOfClonesLeft = this.getClonesLeft();\n      const numberOfClonesRight = this.getClonesRight();\n      const trackLengthMultiplier = 1 + (this.getProp('infinite') ? numberOfClonesLeft + numberOfClonesRight : 0);\n      const trackWidth = this.state.carouselWidth * children.length * trackLengthMultiplier;\n      const animationSpeed = this.getProp('animationSpeed');\n      const transitionEnabled = this.state.transitionEnabled;\n      const draggable = this.getProp('draggable') && children && children.length > 1;\n      const trackStyles = {\n        width: `${trackWidth}px`,\n        transitionDuration: transitionEnabled ? `${animationSpeed}ms, ${animationSpeed}ms` : null\n      };\n\n      if (isRTL) {\n        trackStyles.marginRight = `${this.getAdditionalClonesOffset()}px`;\n        trackStyles.transform = `translateX(${-transformOffset}px)`;\n      } else {\n        trackStyles.marginLeft = `${this.getAdditionalClonesOffset()}px`;\n        trackStyles.transform = `translateX(${transformOffset}px)`;\n      }\n\n      let slides = children;\n\n      if (this.getProp('infinite')) {\n        const clonesLeft = times(numberOfClonesLeft, () => children);\n        const clonesRight = times(numberOfClonesRight, () => children);\n        slides = isRTL ? concat(...clonesRight, children, ...clonesLeft) : concat(...clonesLeft, children, ...clonesRight);\n      }\n\n      const isAutoPlay = this.getProp('autoPlay');\n      const isStopAutoPlayOnHover = this.getProp('stopAutoPlayOnHover');\n\n      const handleAutoPlayEvent = action => isAutoPlay && isStopAutoPlayOnHover ? action : null;\n\n      return React.createElement(\"div\", {\n        className: \"Carousel__trackContainer\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 536\n        },\n        __self: this\n      }, React.createElement(\"ul\", {\n        className: classnames('Carousel__track', {\n          'Carousel__track--transition': transitionEnabled,\n          'Carousel__track--draggable': draggable\n        }),\n        style: trackStyles,\n        ref: el => this.trackRef = el,\n        onMouseEnter: handleAutoPlayEvent(this.onMouseEnter),\n        onMouseLeave: handleAutoPlayEvent(this.onMouseLeave),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 537\n        },\n        __self: this\n      }, slides.map((carouselItem, index) => // eslint-disable-next-line no-undefined\n      [null, undefined].includes(carouselItem) ? null : React.createElement(CarouselItem, {\n        key: index,\n        currentSlideIndex: this.getActiveSlideIndex(),\n        index: index,\n        width: this.getCarouselElementWidth(),\n        offset: index !== slides.length ? this.props.offset : 0,\n        onMouseDown: this.onMouseDown,\n        onTouchStart: this.onTouchStart,\n        clickable: this.getProp('clickToChange'),\n        isDragging: Math.abs(this.state.dragOffset) > this.props.minDraggableOffset,\n        isDraggingEnabled: this.props.draggable || this.props.clickToChange,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 553\n        },\n        __self: this\n      }, carouselItem))));\n    };\n\n    this.renderArrowWithAddedHandler = (element, onClick, name, disable = false) => React.createElement(\"div\", {\n      className: classnames('Carousel__customArrows', {\n        'Carousel__arrow--disable': disable\n      }, `Carousel__custom-${name}`),\n      ref: el => this[`${name}Node`] = el,\n      onClick: this.getProp('addArrowClickHandler') ? onClick : null,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 583\n      },\n      __self: this\n    }, element);\n\n    this.renderArrowLeft = () => {\n      const value = this.getCurrentValue();\n      const disabled = value <= 0 && !this.getProp('infinite');\n\n      if (this.getProp('arrowLeft')) {\n        if (!disabled) {\n          return this.renderArrowWithAddedHandler(this.getProp('arrowLeft'), this.prevSlide, 'arrowLeft');\n        }\n\n        const arrow = this.getProp('arrowLeftDisabled') ? this.getProp('arrowLeftDisabled') : this.getProp('arrowLeft');\n        return this.renderArrowWithAddedHandler(arrow, this.prevSlide, 'arrowLeft', disabled);\n      }\n\n      if (this.getProp('arrows')) {\n        return React.createElement(\"button\", {\n          className: \"Carousel__arrows Carousel__arrowLeft\",\n          onClick: this.prevSlide,\n          ref: el => this.arrowLeftNode = el,\n          disabled: disabled,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 617\n          },\n          __self: this\n        }, React.createElement(\"span\", {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 623\n          },\n          __self: this\n        }, \"prev\"));\n      }\n\n      return null;\n    };\n\n    this.renderArrowRight = () => {\n      const slides = this.getChildren();\n      const value = this.getCurrentValue();\n      const lastSlideIndex = slides.length - 1;\n      const disabled = value === lastSlideIndex && !this.getProp('infinite');\n\n      if (this.getProp('arrowRight')) {\n        if (!disabled) {\n          return this.renderArrowWithAddedHandler(this.getProp('arrowRight'), this.nextSlide, 'arrowRight');\n        }\n\n        const arrow = this.getProp('arrowRightDisabled') ? this.getProp('arrowRightDisabled') : this.getProp('arrowRight');\n        return this.renderArrowWithAddedHandler(arrow, this.nextSlide, 'arrowRight', disabled);\n      }\n\n      if (this.getProp('arrows')) {\n        return React.createElement(\"button\", {\n          className: \"Carousel__arrows Carousel__arrowRight\",\n          onClick: this.nextSlide,\n          ref: el => this.arrowRightNode = el,\n          disabled: disabled,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 649\n          },\n          __self: this\n        }, React.createElement(\"span\", {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 655\n          },\n          __self: this\n        }, \"next\"));\n      }\n\n      return null;\n    };\n\n    this.state = {\n      carouselWidth: 0,\n      windowWidth: 0,\n      clicked: null,\n      dragOffset: 0,\n      dragStart: null,\n      transitionEnabled: false,\n      infiniteTransitionFrom: _props.infinite ? _props.value : null,\n      // indicates what slide we are transitioning from (in case of infinite carousel), contains number value or null\n      isAutoPlayStopped: false\n    };\n    this.interval = null;\n  }\n  /* ========== initial handlers and positioning setup ========== */\n\n\n  componentDidMount() {\n    // adding listener to remove transition when animation finished\n    this.trackRef && this.trackRef.addEventListener('transitionend', this.onTransitionEnd); // adding event listeners for swipe\n\n    if (this.node) {\n      this.node.parentElement.addEventListener('mousemove', this.onMouseMove, true);\n      document.addEventListener('mouseup', this.onMouseUpTouchEnd, true);\n      this.node.parentElement.addEventListener('touchstart', this.simulateEvent, true);\n      this.node.parentElement.addEventListener('touchmove', this.simulateEvent, {\n        passive: false\n      });\n      this.node.parentElement.addEventListener('touchend', this.simulateEvent, true);\n    } // setting size of a carousel in state\n\n\n    window.addEventListener('resize', this.onResize);\n    this.onResize(); // setting size of a carousel in state based on styling\n\n    window.addEventListener('load', this.onResize); // setting autoplay interval\n\n    this.resetInterval();\n  }\n\n  componentDidUpdate(prevProps) {\n    const valueChanged = this.checkIfValueChanged(prevProps);\n\n    if (this.getProp('autoPlay') !== this.getProp('autoPlay', prevProps) || valueChanged) {\n      this.resetInterval();\n    }\n\n    if (valueChanged) {\n      this.setState({\n        transitionEnabled: true\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.trackRef && this.trackRef.removeEventListener('transitionend', this.onTransitionEnd);\n\n    if (this.node) {\n      this.node.parentElement.removeEventListener('mousemove', this.onMouseMove);\n      document.removeEventListener('mouseup', this.onMouseUpTouchEnd);\n      this.node.parentElement.removeEventListener('touchstart', this.simulateEvent);\n      this.node.parentElement.removeEventListener('touchmove', this.simulateEvent);\n      this.node.parentElement.removeEventListener('touchend', this.simulateEvent);\n    }\n\n    window.removeEventListener('resize', this.onResize);\n    window.removeEventListener('load', this.onResize);\n\n    if (this.interval) {\n      clearInterval(this.interval);\n    }\n  }\n  /* ========== tools ========== */\n\n\n  renderDots() {\n    if (this.getProp('dots')) {\n      return React.createElement(Dots, {\n        value: this.getCurrentValue(),\n        onChange: this.changeSlide,\n        number: this.getChildren().length,\n        rtl: this.getProp('rtl'),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 664\n        },\n        __self: this\n      });\n    }\n\n    return null;\n  }\n\n  render() {\n    const isRTL = this.getProp('rtl');\n    return React.createElement(React.Fragment, null, React.createElement(\"div\", {\n      className: \"arrows\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 673\n      },\n      __self: this\n    }, this.renderArrowLeft(), this.renderArrowRight()), React.createElement(\"div\", {\n      className: classnames('Carousel', this.getProp('className'), isRTL ? 'Carousel--isRTL' : ''),\n      ref: el => this.node = el,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 677\n      },\n      __self: this\n    }, this.renderCarouselItems()), this.renderDots());\n  }\n\n}\n\nCarousel.propTypes = {\n  value: PropTypes.number,\n  onChange: PropTypes.func,\n  children: PropTypes.node,\n  slides: PropTypes.arrayOf(PropTypes.node),\n  slidesPerPage: PropTypes.number,\n  slidesPerScroll: PropTypes.number,\n  itemWidth: PropTypes.number,\n  offset: PropTypes.number,\n  arrows: PropTypes.bool,\n  arrowLeft: PropTypes.element,\n  arrowRight: PropTypes.element,\n  addArrowClickHandler: PropTypes.bool,\n  autoPlay: PropTypes.number,\n  stopAutoPlayOnHover: PropTypes.bool,\n  clickToChange: PropTypes.bool,\n  centered: PropTypes.bool,\n  infinite: PropTypes.bool,\n  rtl: PropTypes.bool,\n  draggable: PropTypes.bool,\n  keepDirectionWhenDragging: PropTypes.bool,\n  animationSpeed: PropTypes.number,\n  dots: PropTypes.bool,\n  className: PropTypes.string,\n  minDraggableOffset: PropTypes.number,\n  breakpoints: PropTypes.objectOf(PropTypes.shape({\n    slidesPerPage: PropTypes.number,\n    slidesPerScroll: PropTypes.number,\n    arrows: PropTypes.bool,\n    arrowLeft: PropTypes.element,\n    arrowRight: PropTypes.element,\n    addArrowClickHandler: PropTypes.bool,\n    autoPlay: PropTypes.number,\n    stopAutoPlayOnHover: PropTypes.bool,\n    clickToChange: PropTypes.bool,\n    centered: PropTypes.bool,\n    infinite: PropTypes.bool,\n    draggable: PropTypes.bool,\n    keepDirectionWhenDragging: PropTypes.bool,\n    animationSpeed: PropTypes.number,\n    dots: PropTypes.bool,\n    className: PropTypes.string\n  }))\n};\nCarousel.defaultProps = {\n  offset: 0,\n  slidesPerPage: 1,\n  slidesPerScroll: 1,\n  animationSpeed: 500,\n  draggable: true,\n  rtl: false,\n  minDraggableOffset: 10\n};\nexport default Carousel;","map":{"version":3,"sources":["/home/mindbox/Documents/manoj/nexus/src/components/Carousel/Carousel.js"],"names":["React","Component","throttle","isNil","has","concat","times","PropTypes","classnames","config","CarouselItem","Dots","Carousel","constructor","props","getCurrentValue","infinite","value","clamp","getNeededAdditionalClones","Math","ceil","state","infiniteTransitionFrom","getChildren","length","getAdditionalClonesLeft","additionalClones","getAdditionalClonesRight","getClonesLeft","numberOfInfiniteClones","getClonesRight","getAdditionalClonesOffset","getCarouselElementWidth","getProp","propName","customProps","activeBreakpoint","breakpoints","windowWidth","resolutions","Object","keys","forEach","resolutionString","resolution","parseInt","checkIfValueChanged","prevProps","currentValue","prevValue","resetInterval","interval","clearInterval","autoPlay","setInterval","document","hidden","isAutoPlayStopped","nextSlide","children","slides","Array","isArray","getActiveSlideIndex","getCurrentSlideIndex","getTargetMod","customValue","targetSlide","abs","getTargetSlide","mod","onMouseDown","e","index","preventDefault","stopPropagation","pageX","setState","clicked","dragStart","onMouseMove","previousState","dragOffset","onTouchStart","changedTouches","onMouseUpTouchEnd","clickDragThreshold","changeSlide","getNearestSlideIndex","transitionEnabled","onTransitionEnd","onMouseEnter","onMouseLeave","simulateEvent","touch","screenX","screenY","clientX","clientY","touchEventMap","touchstart","touchmove","touchend","simulatedEvent","MouseEvent","type","bubbles","cancelable","view","window","detail","target","dispatchEvent","maxValue","onChange","prevSlide","slideIndexOffset","floor","round","itemWidth","carouselWidth","getTransformOffset","elementWidthWithOffset","additionalOffset","additionalClonesOffset","renderCarouselItems","isRTL","transformOffset","numberOfClonesLeft","numberOfClonesRight","trackLengthMultiplier","trackWidth","animationSpeed","draggable","trackStyles","width","transitionDuration","marginRight","transform","marginLeft","clonesLeft","clonesRight","isAutoPlay","isStopAutoPlayOnHover","handleAutoPlayEvent","action","el","trackRef","map","carouselItem","undefined","includes","offset","minDraggableOffset","clickToChange","renderArrowWithAddedHandler","element","onClick","name","disable","renderArrowLeft","disabled","arrow","arrowLeftNode","renderArrowRight","lastSlideIndex","arrowRightNode","componentDidMount","addEventListener","node","parentElement","passive","onResize","componentDidUpdate","valueChanged","componentWillUnmount","removeEventListener","renderDots","render","propTypes","number","func","arrayOf","slidesPerPage","slidesPerScroll","arrows","bool","arrowLeft","arrowRight","addArrowClickHandler","stopAutoPlayOnHover","centered","rtl","keepDirectionWhenDragging","dots","className","string","objectOf","shape","defaultProps"],"mappings":"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","sourcesContent":["/* eslint-disable react/no-unused-prop-types */ // we disable propTypes usage checking as we use getProp function\nimport React, { Component } from 'react';\nimport throttle from 'lodash/throttle';\nimport isNil from 'lodash/isNil';\nimport has from 'lodash/has';\nimport concat from 'lodash/concat';\nimport times from 'lodash/times';\nimport PropTypes from 'prop-types';\nimport classnames from 'classnames';\n\nimport config from './Config';\n\nimport CarouselItem from './CarouselItem';\nimport Dots from './CarouselDots';\nimport './Carousel.css';\nimport './Arrows.css';\n\nclass Carousel extends Component {\n  static propTypes = {\n    value: PropTypes.number,\n    onChange: PropTypes.func,\n    children: PropTypes.node,\n    slides: PropTypes.arrayOf(PropTypes.node),\n    slidesPerPage: PropTypes.number,\n    slidesPerScroll: PropTypes.number,\n    itemWidth: PropTypes.number,\n    offset: PropTypes.number,\n    arrows: PropTypes.bool,\n    arrowLeft: PropTypes.element,\n    arrowRight: PropTypes.element,\n    addArrowClickHandler: PropTypes.bool,\n    autoPlay: PropTypes.number,\n    stopAutoPlayOnHover: PropTypes.bool,\n    clickToChange: PropTypes.bool,\n    centered: PropTypes.bool,\n    infinite: PropTypes.bool,\n    rtl: PropTypes.bool,\n    draggable: PropTypes.bool,\n    keepDirectionWhenDragging: PropTypes.bool,\n    animationSpeed: PropTypes.number,\n    dots: PropTypes.bool,\n    className: PropTypes.string,\n    minDraggableOffset: PropTypes.number,\n    breakpoints: PropTypes.objectOf(PropTypes.shape({\n      slidesPerPage: PropTypes.number,\n      slidesPerScroll: PropTypes.number,\n      arrows: PropTypes.bool,\n      arrowLeft: PropTypes.element,\n      arrowRight: PropTypes.element,\n      addArrowClickHandler: PropTypes.bool,\n      autoPlay: PropTypes.number,\n      stopAutoPlayOnHover: PropTypes.bool,\n      clickToChange: PropTypes.bool,\n      centered: PropTypes.bool,\n      infinite: PropTypes.bool,\n      draggable: PropTypes.bool,\n      keepDirectionWhenDragging: PropTypes.bool,\n      animationSpeed: PropTypes.number,\n      dots: PropTypes.bool,\n      className: PropTypes.string,\n    })),\n  };\n  static defaultProps = {\n    offset: 0,\n    slidesPerPage: 1,\n    slidesPerScroll: 1,\n    animationSpeed: 500,\n    draggable: true,\n    rtl: false,\n    minDraggableOffset: 10,\n  };\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      carouselWidth: 0,\n      windowWidth: 0,\n      clicked: null,\n      dragOffset: 0,\n      dragStart: null,\n      transitionEnabled: false,\n      infiniteTransitionFrom: props.infinite ? props.value : null, // indicates what slide we are transitioning from (in case of infinite carousel), contains number value or null\n      isAutoPlayStopped: false,\n    };\n    this.interval = null;\n  }\n\n  /* ========== initial handlers and positioning setup ========== */\n  componentDidMount() {\n    // adding listener to remove transition when animation finished\n    this.trackRef && this.trackRef.addEventListener('transitionend', this.onTransitionEnd);\n\n    // adding event listeners for swipe\n    if (this.node) {\n      this.node.parentElement.addEventListener('mousemove', this.onMouseMove, true);\n      document.addEventListener('mouseup', this.onMouseUpTouchEnd, true);\n      this.node.parentElement.addEventListener('touchstart', this.simulateEvent, true);\n      this.node.parentElement.addEventListener('touchmove', this.simulateEvent, { passive: false });\n      this.node.parentElement.addEventListener('touchend', this.simulateEvent, true);\n    }\n\n    // setting size of a carousel in state\n    window.addEventListener('resize', this.onResize);\n    this.onResize();\n\n    // setting size of a carousel in state based on styling\n    window.addEventListener('load', this.onResize);\n\n    // setting autoplay interval\n    this.resetInterval();\n  }\n\n  componentDidUpdate(prevProps) {\n    const valueChanged = this.checkIfValueChanged(prevProps);\n    if (this.getProp('autoPlay') !== this.getProp('autoPlay', prevProps) || valueChanged) {\n      this.resetInterval();\n    }\n\n    if (valueChanged) {\n      this.setState({\n        transitionEnabled: true,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.trackRef && this.trackRef.removeEventListener('transitionend', this.onTransitionEnd);\n\n    if (this.node) {\n      this.node.parentElement.removeEventListener('mousemove', this.onMouseMove);\n      document.removeEventListener('mouseup', this.onMouseUpTouchEnd);\n      this.node.parentElement.removeEventListener('touchstart', this.simulateEvent);\n      this.node.parentElement.removeEventListener('touchmove', this.simulateEvent);\n      this.node.parentElement.removeEventListener('touchend', this.simulateEvent);\n    }\n\n    window.removeEventListener('resize', this.onResize);\n    window.removeEventListener('load', this.onResize);\n    if (this.interval) {\n      clearInterval(this.interval);\n    }\n  }\n\n  /* ========== tools ========== */\n  getCurrentValue = () => this.props.infinite ? this.props.value : this.clamp(this.props.value);\n\n  getNeededAdditionalClones = () =>\n    Math.ceil((this.getCurrentValue() - this.state.infiniteTransitionFrom) / this.getChildren().length);\n\n  getAdditionalClonesLeft = () => {\n    const additionalClones = this.getNeededAdditionalClones();\n    return additionalClones < 0 ? -additionalClones : 0;\n  };\n  getAdditionalClonesRight = () => {\n    const additionalClones = this.getNeededAdditionalClones();\n    return additionalClones > 0 ? additionalClones : 0;\n  };\n  getClonesLeft = () => config.numberOfInfiniteClones + this.getAdditionalClonesLeft();\n  getClonesRight = () => config.numberOfInfiniteClones + this.getAdditionalClonesRight();\n\n  getAdditionalClonesOffset = () =>\n    -this.getChildren().length * this.getCarouselElementWidth() * this.getAdditionalClonesLeft();\n\n  /**\n   * Returns the value of a prop based on the current window width and breakpoints provided\n   * @param {string} propName name of the prop you want to get\n   * @param {object} customProps props object (used e.g. when you want to get prop from prevProps object instead of this.props)\n   * @return {any} props value\n   */\n  getProp = (propName, customProps = null) => {\n    const props = customProps || this.props;\n    let activeBreakpoint = null;\n    if (props.breakpoints) {\n      const windowWidth = this.state.windowWidth;\n      const resolutions = Object.keys(props.breakpoints);\n      resolutions.forEach(resolutionString => {\n        const resolution = parseInt(resolutionString);\n        if (windowWidth <= resolution) {\n          if (!activeBreakpoint || activeBreakpoint > resolution) {\n            activeBreakpoint = resolution;\n          }\n        }\n      });\n    }\n    if (activeBreakpoint) {\n      if (has(props.breakpoints[activeBreakpoint], propName)) {\n        return props.breakpoints[activeBreakpoint][propName];\n      }\n    }\n    return props[propName];\n  };\n\n  /**\n   * Check if this.props.value changed after update\n   * @param {object} prevProps\n   * @return {boolean} result\n   */\n  checkIfValueChanged = prevProps => {\n    const currentValue = this.getProp('infinite') ? this.props.value : this.clamp(this.props.value);\n    const prevValue = this.getProp('infinite') ? prevProps.value : this.clamp(prevProps.value);\n    return currentValue !== prevValue;\n  };\n\n  resetInterval = () => {\n    if (this.interval) {\n      clearInterval(this.interval);\n    }\n    const autoPlay = this.getProp('autoPlay');\n    if (!isNil(autoPlay)) {\n      this.interval = setInterval(() => {\n        if (!document.hidden && !this.state.isAutoPlayStopped) {\n          this.nextSlide();\n        }\n      }, autoPlay);\n    }\n  };\n\n  getChildren = () => {\n    if (!this.props.children) {\n      if (this.props.slides) {\n        return this.props.slides;\n      }\n      return [];\n    }\n    if (Array.isArray(this.props.children)) {\n      return this.props.children;\n    }\n    return [this.props.children];\n  };\n\n  getActiveSlideIndex = () => this.getProp('infinite')\n    ? this.getCurrentSlideIndex() + this.getClonesLeft() * this.getChildren().length\n    : this.getCurrentSlideIndex();\n\n  getTargetMod = (customValue = null) => {\n    const value = isNil(customValue) ? this.getCurrentValue() : customValue;\n    const length = this.getChildren().length;\n    let targetSlide;\n    if (value >= 0) {\n      targetSlide = value % length;\n    } else {\n      targetSlide = (length - Math.abs(value % length)) % length;\n    }\n    return targetSlide;\n  };\n\n  getTargetSlide = () => {\n    if (!isNil(this.state.infiniteTransitionFrom)) {\n      const mod = this.getTargetMod(this.state.infiniteTransitionFrom);\n      const value = this.getCurrentValue();\n\n      return mod + (value - this.state.infiniteTransitionFrom);\n    }\n    return this.getTargetMod();\n  };\n\n\n  /* event handlers */\n  /**\n   * Handler setting the carouselWidth value in state (used to set proper width of track and slides)\n   * throttled to improve performance\n   * @type {Function}\n   */\n  // onResize = throttle(() => {\n  //   if (!this.node) {\n  //     return;\n  //   }\n\n  //   const arrowLeftWidth = this.arrowLeftNode && this.arrowLeftNode.offsetWidth;\n  //   const arrowRightWidth = this.arrowRightNode && this.arrowRightNode.offsetWidth;\n  //   const width = this.node.offsetWidth - (arrowLeftWidth || 0) - (arrowRightWidth || 0);\n\n  //   this.setState(() => ({\n  //     carouselWidth: width,\n  //     windowWidth: window.innerWidth,\n  //   }));\n  // }, config.resizeEventListenerThrottle);\n\n  /**\n   * Function handling beginning of mouse drag by setting index of clicked item and coordinates of click in the state\n   * @param {event} e event\n   * @param {number} index of the element drag started on\n   */\n  onMouseDown = (e, index) => {\n    e.preventDefault();\n    e.stopPropagation();\n    const { pageX } = e;\n    this.setState(() => ({\n      clicked: index,\n      dragStart: pageX,\n    }));\n  };\n\n  /**\n   * Function handling mouse move if drag has started. Sets dragOffset in the state.\n   * @param {event} e event\n   */\n  onMouseMove = e => {\n    const { pageX } = e;\n    if (this.state.dragStart !== null) {\n      this.setState(previousState => ({\n        dragOffset: this.getProp('rtl') ? previousState.dragStart - pageX : pageX - previousState.dragStart,\n      }));\n    }\n  };\n\n  /**\n   * Function handling beginning of touch drag by setting index of touched item and coordinates of touch in the state\n   * @param {event} e event\n   * @param {number} index of the element drag started on\n   */\n  onTouchStart = (e, index) => {\n    const { changedTouches } = e;\n    this.setState(() => ({\n      clicked: index,\n      dragStart: changedTouches[0].pageX,\n    }));\n  };\n\n  /**\n   * Function handling end of touch or mouse drag. If drag was long it changes current slide to the nearest one,\n   * if drag was short (or it was just a click) it changes slide to the clicked (or touched) one.\n   * It resets clicked index, dragOffset and dragStart values in state.\n   * @param {event} e event\n   */\n  onMouseUpTouchEnd = e => {\n    if (this.state.dragStart !== null) {\n      e.preventDefault();\n      if (this.getProp('draggable') && Math.abs(this.state.dragOffset) > config.clickDragThreshold) {\n        this.changeSlide(this.getNearestSlideIndex());\n      } else if (this.getProp('clickToChange')) {\n        this.changeSlide(\n          this.getProp('infinite')\n            ? this.getCurrentValue() + this.state.clicked - this.getActiveSlideIndex()\n            : this.state.clicked,\n        );\n      }\n      this.setState(() => ({\n        clicked: null,\n        dragOffset: 0,\n        dragStart: null,\n        transitionEnabled: true,\n      }));\n    }\n  };\n\n  /**\n   * Handler setting transitionEnabled value in state to false after transition animation ends\n   */\n  onTransitionEnd = () => {\n    const infinite = this.getProp('infinite');\n    this.setState(() => ({\n      transitionEnabled: !infinite,\n      infiniteTransitionFrom: infinite ? this.getCurrentValue() : null,\n    }));\n  };\n\n  /**\n   * Function handling mouse hover over element\n   * Stops auto play\n   */\n  onMouseEnter = () => {\n    this.setState(() => ({\n      isAutoPlayStopped: true,\n    }));\n  };\n\n  /**\n   * Function handling mouse leaving element\n   * Resumes auto play\n   */\n  onMouseLeave = () => {\n    this.setState(() => ({\n      isAutoPlayStopped: false,\n    }));\n    this.resetInterval();\n  };\n\n  /**\n   * Simulates mouse events when touch events occur\n   * @param {event} e A touch event\n   */\n  simulateEvent = e => {\n    const touch = e.changedTouches[0];\n    const {\n      screenX,\n      screenY,\n      clientX,\n      clientY,\n    } = touch;\n    const touchEventMap = {\n      touchstart: 'mousedown',\n      touchmove: 'mousemove',\n      touchend: 'mouseup',\n    };\n    const simulatedEvent = new MouseEvent(\n      touchEventMap[e.type],\n      {\n        bubbles: true,\n        cancelable: true,\n        view: window,\n        detail: 1,\n        screenX,\n        screenY,\n        clientX,\n        clientY,\n      },\n    );\n    touch.target.dispatchEvent(simulatedEvent);\n  };\n\n\n  /* ========== control ========== */\n  /**\n   * Clamps number between 0 and last slide index.\n   * @param {number} value to be clamped\n   * @return {number} new value\n   */\n  clamp = value => {\n    const maxValue = this.getChildren().length - 1;\n    if (value > maxValue) {\n      return maxValue;\n    }\n    if (value < 0) {\n      return 0;\n    }\n    return value;\n  };\n\n  /**\n   * Clamps a provided value and triggers onChange\n   * @param {number} value desired index to change current value to\n   * @return {undefined}\n   */\n  changeSlide = value => this.props.onChange(this.getProp('infinite') ? value : this.clamp(value));\n\n  nextSlide = () => this.changeSlide(this.getCurrentValue() + this.getProp('slidesPerScroll'));\n\n  prevSlide = () => this.changeSlide(this.getCurrentValue() - this.getProp('slidesPerScroll'));\n\n\n  /* ========== positioning ========== */\n  /**\n   * Checks what slide index is the nearest to the current position (to calculate the result of dragging the slider)\n   * @return {number} index\n   */\n  getNearestSlideIndex = () => {\n    let slideIndexOffset = 0;\n    if (this.getProp('keepDirectionWhenDragging')) {\n      if (this.state.dragOffset > 0) {\n        slideIndexOffset = -Math.ceil(this.state.dragOffset / this.getCarouselElementWidth());\n      } else {\n        slideIndexOffset = -Math.floor(this.state.dragOffset / this.getCarouselElementWidth());\n      }\n    } else {\n      slideIndexOffset = -Math.round(this.state.dragOffset / this.getCarouselElementWidth());\n    }\n    return this.getCurrentValue() + slideIndexOffset;\n  };\n\n  /**\n   * Returns the current slide index (from either props or internal state)\n   * @return {number} index\n   */\n  getCurrentSlideIndex = () => {\n    if (this.getProp('infinite')) {\n      return this.getTargetSlide();\n    }\n    return this.clamp(this.getCurrentValue());\n  };\n\n  /**\n   * Calculates width of a single slide in a carousel\n   * @return {number} width of a slide in px\n   */\n  getCarouselElementWidth = () => this.props.itemWidth || this.state.carouselWidth / this.getProp('slidesPerPage');\n\n  /**\n   * Calculates offset in pixels to be applied to Track element in order to show current slide correctly (centered or aligned to the left)\n   * @return {number} offset in px\n   */\n  getTransformOffset = () => {\n    const elementWidthWithOffset = this.getCarouselElementWidth() + this.getProp('offset');\n    const additionalOffset = this.getProp('centered')\n      ? (this.state.carouselWidth / 2) - (elementWidthWithOffset / 2)\n      : 0;\n    const dragOffset = this.getProp('draggable') ? this.state.dragOffset : 0;\n    const currentValue = this.getActiveSlideIndex();\n    const additionalClonesOffset = this.getAdditionalClonesOffset();\n\n    return dragOffset - currentValue * elementWidthWithOffset + additionalOffset - additionalClonesOffset;\n  };\n\n\n  /* ========== rendering ========== */\n  renderCarouselItems = () => {\n    const isRTL = this.getProp('rtl');\n    const transformOffset = this.getTransformOffset();\n    const children = this.getChildren();\n    const numberOfClonesLeft = this.getClonesLeft();\n    const numberOfClonesRight = this.getClonesRight();\n\n    const trackLengthMultiplier = 1 + (this.getProp('infinite') ? numberOfClonesLeft + numberOfClonesRight : 0);\n    const trackWidth = this.state.carouselWidth * children.length * trackLengthMultiplier;\n    const animationSpeed = this.getProp('animationSpeed');\n    const transitionEnabled = this.state.transitionEnabled;\n    const draggable = this.getProp('draggable') && children && children.length > 1;\n\n    const trackStyles = {\n      width: `${trackWidth}px`,\n      transitionDuration: transitionEnabled ? `${animationSpeed}ms, ${animationSpeed}ms` : null,\n    };\n\n    if (isRTL) {\n      trackStyles.marginRight = `${this.getAdditionalClonesOffset()}px`;\n      trackStyles.transform = `translateX(${-transformOffset}px)`;\n    } else {\n      trackStyles.marginLeft = `${this.getAdditionalClonesOffset()}px`;\n      trackStyles.transform = `translateX(${transformOffset}px)`;\n    }\n\n    let slides = children;\n    if (this.getProp('infinite')) {\n      const clonesLeft = times(numberOfClonesLeft, () => children);\n      const clonesRight = times(numberOfClonesRight, () => children);\n      slides = isRTL\n        ? concat(...clonesRight, children, ...clonesLeft)\n        : concat(...clonesLeft, children, ...clonesRight);\n    }\n\n    const isAutoPlay = this.getProp('autoPlay');\n    const isStopAutoPlayOnHover = this.getProp('stopAutoPlayOnHover');\n    const handleAutoPlayEvent = action => (isAutoPlay && isStopAutoPlayOnHover) ? action : null;\n\n    return (\n      <div className=\"Carousel__trackContainer\">\n        <ul\n          className={classnames(\n            'Carousel__track',\n            {\n              'Carousel__track--transition': transitionEnabled,\n              'Carousel__track--draggable': draggable,\n            },\n          )}\n          style={trackStyles}\n          ref={el => this.trackRef = el}\n          onMouseEnter={handleAutoPlayEvent(this.onMouseEnter)}\n          onMouseLeave={handleAutoPlayEvent(this.onMouseLeave)}\n        >\n          {slides.map((carouselItem, index) => (\n            // eslint-disable-next-line no-undefined\n            [null, undefined].includes(carouselItem) ? null : (\n              <CarouselItem\n                key={index}\n                currentSlideIndex={this.getActiveSlideIndex()}\n                index={index}\n                width={this.getCarouselElementWidth()}\n                offset={index !== slides.length ? this.props.offset : 0}\n                onMouseDown={this.onMouseDown}\n                onTouchStart={this.onTouchStart}\n                clickable={this.getProp('clickToChange')}\n                isDragging={Math.abs(this.state.dragOffset) > this.props.minDraggableOffset}\n                isDraggingEnabled={this.props.draggable || this.props.clickToChange}\n              >\n                {carouselItem}\n              </CarouselItem>\n            )\n          ))}\n        </ul>\n      </div>\n    );\n  };\n\n  /**\n   * Adds onClick handler to the arrow if possible (if it does not already have one)\n   * @param {ReactElement} element to render\n   * @param {function} onClick handler to be added to element\n   * @param {string} name of an element\n   * @param {boolean} disable info whether the arrow is disabled\n   * @return {ReactElement} element with added handler\n   */\n  renderArrowWithAddedHandler = (element, onClick, name, disable = false) => (\n    <div\n      className={\n        classnames(\n          'Carousel__customArrows',\n          {\n            'Carousel__arrow--disable': disable,\n          },\n          `Carousel__custom-${name}`,\n        )\n      }\n      ref={el => this[`${name}Node`] = el}\n      onClick={this.getProp('addArrowClickHandler') ? onClick : null}\n    >\n      {element}\n    </div>\n  );\n\n  /**\n   * Renders arrow left\n   * @return {ReactElement} element\n   */\n  renderArrowLeft = () => {\n    const value = this.getCurrentValue();\n    const disabled = value <= 0 && !this.getProp('infinite');\n\n    if (this.getProp('arrowLeft')) {\n      if (!disabled) {\n        return this.renderArrowWithAddedHandler(this.getProp('arrowLeft'), this.prevSlide, 'arrowLeft');\n      }\n      const arrow = this.getProp('arrowLeftDisabled') ? this.getProp('arrowLeftDisabled') : this.getProp('arrowLeft');\n      return this.renderArrowWithAddedHandler(arrow, this.prevSlide, 'arrowLeft', disabled);\n    }\n    if (this.getProp('arrows')) {\n      return (\n        <button\n          className=\"Carousel__arrows Carousel__arrowLeft\"\n          onClick={this.prevSlide}\n          ref={el => this.arrowLeftNode = el}\n          disabled={disabled}\n        >\n          <span>prev</span>\n        </button>\n      );\n    }\n    return null;\n  };\n\n  /**\n   * Renders arrow right\n   * @return {ReactElement} element\n   */\n  renderArrowRight = () => {\n    const slides = this.getChildren();\n    const value = this.getCurrentValue();\n    const lastSlideIndex = slides.length - 1;\n    const disabled = value === lastSlideIndex && !this.getProp('infinite');\n\n    if (this.getProp('arrowRight')) {\n      if (!disabled) {\n        return this.renderArrowWithAddedHandler(this.getProp('arrowRight'), this.nextSlide, 'arrowRight');\n      }\n      const arrow = this.getProp('arrowRightDisabled') ? this.getProp('arrowRightDisabled') : this.getProp('arrowRight');\n      return this.renderArrowWithAddedHandler(arrow, this.nextSlide, 'arrowRight', disabled);\n    }\n    if (this.getProp('arrows')) {\n      return (\n        <button\n          className=\"Carousel__arrows Carousel__arrowRight\"\n          onClick={this.nextSlide}\n          ref={el => this.arrowRightNode = el}\n          disabled={disabled}\n        >\n          <span>next</span>\n        </button>\n      );\n    }\n    return null;\n  };\n\n  renderDots() {\n    if (this.getProp('dots')) {\n      return <Dots value={this.getCurrentValue()} onChange={this.changeSlide} number={this.getChildren().length} rtl={this.getProp('rtl')} />;\n    }\n    return null;\n  }\n\n  render() {\n    const isRTL = this.getProp('rtl');\n    return (\n      <>\n        <div className=\"arrows\">\n          {this.renderArrowLeft()}\n          {this.renderArrowRight()}\n        </div>\n        <div\n          className={classnames('Carousel', this.getProp('className'), isRTL ? 'Carousel--isRTL' : '')}\n          ref={el => this.node = el}\n        >\n          {this.renderCarouselItems()}\n        </div>\n        {this.renderDots()}\n      </>\n    );\n  }\n}\n\nexport default Carousel;"]},"metadata":{},"sourceType":"module"}