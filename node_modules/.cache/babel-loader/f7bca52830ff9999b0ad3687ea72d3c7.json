{"ast":null,"code":"var _jsxFileName = \"/home/mindbox/Documents/manoj/nexus/src/components/Carousel/Carousel.js\";\nimport React, { useState, useEffect, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport Index from './Index';\nconst styles = {\n  wrapper: {\n    width: '100%',\n    height: '100%',\n    position: 'relative'\n  },\n  frame: {\n    // width: '100%',\n    height: '100%',\n    position: 'absolute'\n  }\n};\n\nclass Carousel extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      frames: [].concat(props.frames || props.children || []),\n      current: 0\n    };\n    this.mounted = false;\n    this.debounceTimeoutId = null;\n    this.onTouchStart = this.onTouchStart.bind(this);\n    this.onTouchMove = this.onTouchMove.bind(this);\n    this.onTouchEnd = this.onTouchEnd.bind(this);\n    this.onResize = this.onResize.bind(this);\n    this.autoSlide = this.autoSlide.bind(this);\n    this.prev = this.prev.bind(this);\n    this.next = this.next.bind(this);\n\n    if (props.loop === false && props.auto) {\n      console.warn('[re-carousel] Auto-slide only works in loop mode.');\n    }\n  }\n\n  componentDidMount() {\n    this.mounted = true;\n    this.prepareAutoSlide();\n    this.hideFrames();\n    this.refs.wrapper.addEventListener('touchmove', this.onTouchMove, {\n      capture: true\n    });\n    this.refs.wrapper.addEventListener('touchend', this.onTouchEnd, {\n      capture: true\n    });\n    window.addEventListener('resize', this.onResize);\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n    this.clearAutoTimeout();\n    this.refs.wrapper.removeEventListener('touchmove', this.onTouchMove, {\n      capture: true\n    });\n    this.refs.wrapper.removeEventListener('touchend', this.onTouchEnd, {\n      capture: true\n    });\n    window.removeEventListener('resize', this.onResize);\n  }\n\n  componentDidUpdate(_, prevState) {\n    if (this.state.frames.length && this.state.frames.length !== prevState.frames.length) {\n      // reset to default state\n      this.hideFrames();\n      this.prepareAutoSlide();\n    }\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    const frames = [].concat(nextProps.frames || nextProps.children || []);\n    const nextState = {\n      frames\n    };\n\n    if (frames.length && frames.length !== prevState.frames.length) {\n      nextState.current = 0;\n    }\n\n    return nextState;\n  }\n\n  hideFrames() {\n    for (let i = 1; i < this.state.frames.length; i++) {\n      this.refs['f' + i].style.opacity = 0;\n    }\n  }\n\n  onResize() {\n    clearTimeout(this.debounceTimeoutId);\n    this.debounceTimeoutId = setTimeout(() => {\n      this.updateFrameSize(() => {\n        this.prepareSiblingFrames();\n      });\n    }, 25);\n  }\n\n  onTouchStart(e) {\n    if (this.state.total < 2) return; // e.preventDefault()\n\n    this.clearAutoTimeout();\n    this.updateFrameSize();\n    this.prepareSiblingFrames();\n    const {\n      pageX,\n      pageY\n    } = e.touches && e.touches[0] || e;\n    this.setState({\n      startX: pageX,\n      startY: pageY,\n      deltaX: 0,\n      deltaY: 0\n    });\n    this.refs.wrapper.addEventListener('mousemove', this.onTouchMove, {\n      capture: true\n    });\n    this.refs.wrapper.addEventListener('mouseup', this.onTouchEnd, {\n      capture: true\n    });\n    this.refs.wrapper.addEventListener('mouseleave', this.onTouchEnd, {\n      capture: true\n    });\n  }\n\n  onTouchMove(e) {\n    if (e.touches && e.touches.length > 1) return;\n    this.clearAutoTimeout();\n    const {\n      pageX,\n      pageY\n    } = e.touches && e.touches[0] || e;\n    let deltaX = pageX - this.state.startX;\n    let deltaY = pageY - this.state.startY;\n    this.setState({\n      deltaX: deltaX,\n      deltaY: deltaY\n    });\n\n    if (this.props.axis === 'x' && Math.abs(deltaX) > Math.abs(deltaY)) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    if (this.props.axis === 'y' && Math.abs(deltaY) > Math.abs(deltaX)) {\n      e.preventDefault();\n      e.stopPropagation();\n    } // when reach frames edge in non-loop mode, reduce drag effect.\n\n\n    if (!this.props.loop) {\n      if (this.state.current === this.state.frames.length - 1) {\n        deltaX < 0 && (deltaX /= 3);\n        deltaY < 0 && (deltaY /= 3);\n      }\n\n      if (this.state.current === 0) {\n        deltaX > 0 && (deltaX /= 3);\n        deltaY > 0 && (deltaY /= 3);\n      }\n    }\n\n    this.moveFramesBy(deltaX, deltaY);\n  }\n\n  onTouchEnd() {\n    const direction = this.decideEndPosition();\n    direction && this.transitFramesTowards(direction); // cleanup\n\n    this.refs.wrapper.removeEventListener('mousemove', this.onTouchMove, {\n      capture: true\n    });\n    this.refs.wrapper.removeEventListener('mouseup', this.onTouchEnd, {\n      capture: true\n    });\n    this.refs.wrapper.removeEventListener('mouseleave', this.onTouchEnd, {\n      capture: true\n    });\n    setTimeout(() => this.prepareAutoSlide(), this.props.duration);\n  }\n\n  decideEndPosition() {\n    const {\n      deltaX = 0,\n      deltaY = 0,\n      current,\n      frames\n    } = this.state;\n    const {\n      axis,\n      loop,\n      minMove\n    } = this.props;\n\n    switch (axis) {\n      case 'x':\n        if (loop === false) {\n          if (current === 0 && deltaX > 0) return 'origin';\n          if (current === frames.length - 1 && deltaX < 0) return 'origin';\n        }\n\n        if (Math.abs(deltaX) < minMove) return 'origin';\n        return deltaX > 0 ? 'right' : 'left';\n\n      case 'y':\n        if (loop === false) {\n          if (current === 0 && deltaY > 0) return 'origin';\n          if (current === frames.length - 1 && deltaY < 0) return 'origin';\n        }\n\n        if (Math.abs(deltaY) < minMove) return 'origin';\n        return deltaY > 0 ? 'down' : 'up';\n\n      default:\n    }\n  }\n\n  moveFramesBy(deltaX, deltaY) {\n    const {\n      prev,\n      current,\n      next\n    } = this.state.movingFrames;\n    const {\n      frameWidth,\n      frameHeight\n    } = this.state;\n\n    switch (this.props.axis) {\n      case 'x':\n        translateXY(current, deltaX, 0);\n\n        if (deltaX < 0) {\n          translateXY(next, deltaX + frameWidth, 0);\n        } else {\n          translateXY(prev, deltaX - frameWidth, 0);\n        }\n\n        break;\n\n      case 'y':\n        translateXY(current, 0, deltaY);\n\n        if (deltaY < 0) {\n          translateXY(next, 0, deltaY + frameHeight);\n        } else {\n          translateXY(prev, 0, deltaY - frameHeight);\n        }\n\n        break;\n\n      default:\n    }\n  }\n\n  prepareAutoSlide() {\n    if (this.state.frames.length < 2) return;\n    this.clearAutoTimeout();\n    this.updateFrameSize(() => {\n      this.prepareSiblingFrames();\n    }); // auto slide only avalible in loop mode\n\n    if (this.mounted && this.props.loop && this.props.auto) {\n      const slideTimeoutID = setTimeout(this.autoSlide, this.props.interval);\n      this.setState({\n        slider: slideTimeoutID\n      });\n    }\n  } // auto slide to 'next' or 'prev'\n\n\n  autoSlide(rel) {\n    this.clearAutoTimeout();\n\n    switch (rel) {\n      case 'prev':\n        this.transitFramesTowards(this.props.axis === 'x' ? 'right' : 'down');\n        break;\n\n      case 'next':\n      default:\n        this.transitFramesTowards(this.props.axis === 'x' ? 'left' : 'up');\n    } // prepare next move after animation\n\n\n    setTimeout(() => this.prepareAutoSlide(), this.props.duration);\n  }\n\n  next() {\n    const {\n      current,\n      frames\n    } = this.state;\n    if (!this.props.loop && current === frames.length - 1) return false;\n    this.autoSlide('next');\n  }\n\n  prev() {\n    if (!this.props.loop && this.state.current === 0) return false;\n    const {\n      prev,\n      next\n    } = this.state.movingFrames;\n\n    if (prev === next) {\n      // Reprepare start position of prev frame\n      // (it was positioned as \"next\" frame)\n      if (this.props.axis === 'x') {\n        translateXY(prev, -this.state.frameWidth, 0, 0);\n      } else {\n        translateXY(prev, 0, -this.state.frameHeight, 0);\n      }\n\n      prev.getClientRects(); // trigger layout\n    }\n\n    this.autoSlide('prev');\n  }\n\n  clearAutoTimeout() {\n    clearTimeout(this.state.slider);\n  }\n\n  updateFrameSize(cb) {\n    const {\n      width,\n      height\n    } = window.getComputedStyle(this.refs.wrapper);\n    this.setState({\n      frameWidth: parseFloat(width.split('%')[0]),\n      frameHeight: parseFloat(height.split('%')[0])\n    }, cb);\n  }\n\n  getSiblingFrames() {\n    return {\n      current: this.refs['f' + this.getFrameId()],\n      prev: this.refs['f' + this.getFrameId('prev')],\n      next: this.refs['f' + this.getFrameId('next')]\n    };\n  }\n\n  prepareSiblingFrames() {\n    const siblings = this.getSiblingFrames();\n\n    if (!this.props.loop) {\n      this.state.current === 0 && (siblings.prev = undefined);\n      this.state.current === this.state.frames.length - 1 && (siblings.next = undefined);\n    }\n\n    this.setState({\n      movingFrames: siblings\n    }); // prepare frames position\n\n    translateXY(siblings.current, 0, 0);\n\n    if (this.props.axis === 'x') {\n      translateXY(siblings.prev, -this.state.frameWidth, 0);\n      translateXY(siblings.next, this.state.frameWidth, 0);\n    } else {\n      translateXY(siblings.prev, 0, -this.state.frameHeight);\n      translateXY(siblings.next, 0, this.state.frameHeight);\n    }\n\n    return siblings;\n  }\n\n  getFrameId(pos) {\n    const {\n      frames,\n      current\n    } = this.state;\n    const total = frames.length;\n\n    switch (pos) {\n      case 'prev':\n        return (current - 1 + total) % total;\n\n      case 'next':\n        return (current + 1) % total;\n\n      default:\n        return current;\n    }\n  }\n\n  transitFramesTowards(direction) {\n    const {\n      prev,\n      current,\n      next\n    } = this.state.movingFrames;\n    const {\n      duration,\n      axis,\n      onTransitionEnd\n    } = this.props;\n    let newCurrentId = this.state.current;\n\n    switch (direction) {\n      case 'up':\n        translateXY(current, 0, -this.state.frameHeight, duration);\n        translateXY(next, 0, 0, duration);\n        newCurrentId = this.getFrameId('next');\n        break;\n\n      case 'down':\n        translateXY(current, 0, this.state.frameHeight, duration);\n        translateXY(prev, 0, 0, duration);\n        newCurrentId = this.getFrameId('prev');\n        break;\n\n      case 'left':\n        translateXY(current, -this.state.frameWidth, 0, duration);\n        translateXY(next, 0, 0, duration);\n        newCurrentId = this.getFrameId('next');\n        break;\n\n      case 'right':\n        translateXY(current, this.state.frameWidth, 0, duration);\n        translateXY(prev, 0, 0, duration);\n        newCurrentId = this.getFrameId('prev');\n        break;\n\n      default:\n        // back to origin\n        translateXY(current, 0, 0, duration);\n\n        if (axis === 'x') {\n          translateXY(prev, -this.state.frameWidth, 0, duration);\n          translateXY(next, this.state.frameWidth, 0, duration);\n        } else if (axis === 'y') {\n          translateXY(prev, 0, -this.state.frameHeight, duration);\n          translateXY(next, 0, this.state.frameHeight, duration);\n        }\n\n    }\n\n    onTransitionEnd && setTimeout(() => onTransitionEnd(this.getSiblingFrames()), duration);\n    this.setState({\n      current: newCurrentId\n    });\n  } // debugFrames () {\n  //   console.log('>>> DEBUG-FRAMES: current', this.state.current)\n  //   const len = this.state.frames.length\n  //   for (let i = 0; i < len; ++i) {\n  //     const ref = this.refs['f' + i]\n  //     console.info(ref.innerText.trim(), ref.style.transform)\n  //   }\n  // }\n\n\n  render() {\n    const {\n      frames,\n      current\n    } = this.state;\n    const {\n      widgets,\n      axis,\n      loop,\n      auto,\n      interval\n    } = this.props;\n    const wrapperStyle = objectAssign(styles.wrapper, this.props.style);\n    /* Default Properties */\n\n    const IMG_WIDTH = 300;\n    const IMG_HEIGHT = 300;\n    const parentPad = 0;\n    const VISIBLEIMAGES = 3;\n    const DURATION = 750;\n    const {\n      imgList = [],\n      img_width = IMG_WIDTH,\n      img_height = IMG_HEIGHT,\n      visibleImages = VISIBLEIMAGES,\n      duration = DURATION,\n      autoNext = false,\n      timeForNext = 5000\n    } = this.props;\n    /* Hooks Declarations Start*/\n\n    const [currFirstImg, setCurrFirstImg] = useState(0); // The Current Middle Element/Primary element of our carousel\n\n    const [actualFirst, setActualFirst] = useState(''); // The Clicked Image when it is not the Immediate Next or Immediate Previous Image\n\n    const [visibleItemsProps, setVisibleItemsProps] = useState({\n      order: [],\n      styles: {}\n    }); // Set Styles and ordering to Images currently visible\n\n    const currMiddleImgRef = useRef(0); // Reference for the image that is in the middle\n\n    const intervalRef = useRef(0); // Reference to interval so that it can be removed from within/ before initiating new interval\n\n    const imgDifference = useRef(1); // The difference between the middle image and the image that is clicked by user to view next\n\n    const durationRef = useRef(duration); // Animation Duration, it should be changed when the image cicked is not immediate next/prev\n\n    /* Hooks Declarations End*/\n\n    const parentHeight = img_height + 2 * parentPad; // To avoid overlap with Carousel Component's siblings, since all images are absolutely positioned\n\n    const parentWidth = img_width * 3; // To have thrice the width of an individual image\n\n    const elementsInLeft = Math.ceil(visibleImages / 2); // Floor is done to also include middle image along with other images to its left.\n\n    const elementsInRight = visibleImages - elementsInLeft;\n\n    const constructVisibleItemsProps = () => {\n      const visibleItemsProps = {}; // To store config for items that are visibile in the carousel\n\n      visibleItemsProps.order = [];\n      let curr_center = currFirstImg; // Storing the Current Middle element in focus\n\n      let timesToIterate = 0; // To iterate through all visible number of images.\n\n      let zIndex = -elementsInRight; // We start from left to right and Zindex has to keep on increasing till middle then has to reduce.\n\n      let xTranslate = img_width; // To move the element with respect to x axis\n\n      let zTranslate = 0; // To reduce image size for images apart from center\n\n      let opacity = 1;\n      const division = img_width * (1.66 / elementsInLeft); // Specifies the length that next image has to move away from with resoect to current image (1.6 times the current image)\n\n      let opacityDivider = 0.7 / elementsInRight; // minimum opacity should be 0.3 (1-0.7)\n\n      let rightEltCount = elementsInRight;\n      let leftEltCount = elementsInLeft; // including middle element\n\n      let curr_center_copy = curr_center;\n\n      while (timesToIterate < visibleImages) {\n        const styles = {};\n        let currImgIndex;\n        let currImgIndexOnRight = true; // Tells if in this iteration the currently iterated image lies left to the middle image or not\n        // To set properties for elements in right side\n\n        if (timesToIterate < elementsInRight) {\n          const nextIndex = curr_center - rightEltCount;\n          currImgIndex = nextIndex > -1 ? nextIndex : imgList.length - Math.abs(nextIndex); // Gives the rightmost elemnt in first iteration and then the subsequent elements down the iteration\n\n          opacity = 1 - opacityDivider * rightEltCount; // To assign lowest opacity to last element and increaing it till we come to middle\n\n          zTranslate = -division * rightEltCount; // To increase the size of the images subsequently from last to middle\n\n          xTranslate = img_width - division * rightEltCount; // X coordinate position\n\n          rightEltCount--;\n        } else {\n          // To set properties for elements in center and to left of it. All props behaves similar to right\n          currImgIndexOnRight = false;\n          currImgIndex = curr_center_copy;\n\n          if (curr_center_copy + 1 >= imgList.length) {\n            // to maintain cyclic carousel\n            curr_center_copy = 0;\n          } else {\n            curr_center_copy++;\n          }\n\n          opacity = 1 - opacityDivider * Math.abs(leftEltCount - (timesToIterate + 1));\n          zTranslate = -division * Math.abs(leftEltCount - (timesToIterate + 1));\n          xTranslate = img_width + division * Math.abs(leftEltCount - (timesToIterate + 1));\n        } // Assigning above calculated values to 'styles' object\n\n\n        styles.transform = 'translateX(' + xTranslate + 'px) translateZ(' + zTranslate + 'px)';\n        styles.opacity = opacity;\n        styles.zIndex = currImgIndexOnRight ? zIndex++ : zIndex--; // To reduce zIndex while going through left elements\n\n        visibleItemsProps.order.push(currImgIndex); // Push the current image number in the orders array\n\n        visibleItemsProps[currImgIndex] = {\n          styles\n        }; // pushing all previously created styles\n\n        timesToIterate++;\n      }\n\n      durationRef.current = actualFirst === '' ? duration : duration / imgDifference.current; // duration will be user given if he clicks next image or we divide the duration by number of images skipped\n\n      setVisibleItemsProps(visibleItemsProps); // setting state for visible items\n    };\n\n    const changeCenter = ({\n      event,\n      index,\n      large_url\n    }) => {\n      // Checking if the clicked item is immediately next/prev item.Because to induce a carousel effect we need to make the images move in sequence.\n      // But that is not possible, when the user clicks out of sequence(Eg: image 4 from image 1).So here, the order breaks and we cannot \n      // apply our sequential handling logic to it. If we do the 4th image comes into view from the back but the \"cycling effect\"\n      // of scrolling through images 2 and 3 would have been missed.\n      const currFirstImgIndex = visibleItemsProps.order.indexOf(currFirstImg);\n      const prevIndex = visibleItemsProps.order[currFirstImgIndex - 1];\n      const nextIndex = visibleItemsProps.order[currFirstImgIndex + 1];\n\n      if (index !== currFirstImg) {\n        if (index === prevIndex || index === nextIndex) {\n          // if immediate first/next image\n          setCurrFirstImg(index);\n        } else {\n          const val = currFirstImgIndex - visibleItemsProps.order.indexOf(index);\n          imgDifference.current = Math.abs(val); // Gives the number of images we have to cycle through, so we can provide equal part of total duration to all images.\n\n          setActualFirst(index);\n          cycleToNextImage(index);\n        }\n      } else {\n        window.open(large_url); // Can have a callback in props and execute it on click.\n      }\n    }; // To show the subsequent image based on if the user has clicked on the right side or on the left side of the middle image\n\n\n    const cycleToNextImage = actual => {\n      if (visibleItemsProps.order.indexOf(currMiddleImgRef.current) > visibleItemsProps.order.indexOf(actual)) {\n        // Right side image click\n        currMiddleImgRef.current = currMiddleImgRef.current - 1 > -1 ? currMiddleImgRef.current - 1 : imgList.length - 1; // Right side image click\n\n        setCurrFirstImg(currMiddleImgRef.current);\n      } else {\n        // Left side image click\n        currMiddleImgRef.current = currMiddleImgRef.current + 1 < imgList.length ? currMiddleImgRef.current + 1 : 0; // Conditions to handle cycle\n\n        setCurrFirstImg(currMiddleImgRef.current);\n      }\n    }; // Hook fires on evey change to actualFirst value. actualFirst is set when there is out of order click, so we have to handle it through timeinterval\n    // so that we can allow all intermediate images to do some animation in the meantime, to avoid the cycling look jerky.\n\n\n    useEffect(() => {\n      clearInterval(intervalRef.current);\n\n      if (actualFirst !== '') {\n        intervalRef.current = setInterval(() => {\n          if (actualFirst !== '' && actualFirst !== currMiddleImgRef.current) {\n            // If the currentimage in middle is not actually clicked image then gotoNext image\n            cycleToNextImage(actualFirst);\n          } else if (actualFirst !== '' && actualFirst === currMiddleImgRef.current) {\n            setActualFirst('');\n            imgDifference.current = 1;\n            clearInterval(intervalRef.current); // If actual clicked and middle image are same we are all set to clear intervals, as they are unnecessary now\n          }\n        }, durationRef.current - 100); // Introduced an advance of 100ms to begin bringing nextimage to middle before the previous one settles down else it looks jerky\n      }\n    }, [actualFirst]);\n    useEffect(() => {\n      constructVisibleItemsProps(); // This constructs all css properties to the elements in visibility\n\n      currMiddleImgRef.current = currFirstImg; // Need to set it here as well so while accessing inside interval it will have the latest value\n    }, [currFirstImg]);\n    useEffect(() => {\n      if (autoNext) {\n        setInterval(() => {\n          const nextImg = currMiddleImgRef.current + 1 < imgList.length ? currMiddleImgRef.current + 1 : 0;\n          setCurrFirstImg(nextImg);\n        }, timeForNext);\n      }\n    }, []);\n    return React.createElement(\"div\", {\n      style: wrapperStyle,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 516\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      ref: \"wrapper\",\n      style: objectAssign({\n        overflow: 'hidden'\n      }, wrapperStyle),\n      onTouchStart: this.onTouchStart,\n      className: this.props.className,\n      onMouseDown: this.onTouchStart,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 517\n      },\n      __self: this\n    }, frames.map((frame, i) => {\n      const frameStyle = objectAssign({\n        zIndex: 99 - i\n      }, styles.frame);\n      return React.createElement(\"div\", {\n        ref: 'f' + i,\n        key: i,\n        style: frameStyle,\n        className: `${current === i ? 'current slide' : 'slide'}`,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 526\n        },\n        __self: this\n      }, frame);\n    }), this.props.frames && this.props.children), widgets && [].concat(widgets).map((Widget, i) => React.createElement(Widget, {\n      key: i,\n      index: current,\n      total: frames.length,\n      prevHandler: this.prev,\n      nextHandler: this.next,\n      axis: axis,\n      loop: loop,\n      auto: auto,\n      interval: interval,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 533\n      },\n      __self: this\n    })));\n  }\n\n}\n\nCarousel.propTypes = {\n  axis: PropTypes.oneOf(['x', 'y']),\n  auto: PropTypes.bool,\n  loop: PropTypes.bool,\n  interval: PropTypes.number,\n  duration: PropTypes.number,\n  widgets: PropTypes.arrayOf(PropTypes.func),\n  frames: PropTypes.arrayOf(PropTypes.element),\n  style: PropTypes.object,\n  minMove: PropTypes.number,\n  onTransitionEnd: PropTypes.func\n};\nCarousel.defaultProps = {\n  axis: 'x',\n  auto: false,\n  loop: false,\n  interval: 5000,\n  duration: 300,\n  minMove: 42\n};\n\nfunction translateXY(el, x, y, duration = 0) {\n  if (!el) return;\n  el.style.opacity = '1'; // animation\n\n  el.style.transitionDuration = duration + 'ms';\n  el.style.webkitTransitionDuration = duration + 'ms';\n  el.currentItem = `translate(${x}px, ${y}px)`;\n  el.style.transform = `translate(${x}px, ${y}px)`;\n  el.style.webkitTransform = `translate(${x}px, ${y}px) translateZ(0)`;\n}\n\nfunction objectAssign(target) {\n  var output = Object(target);\n\n  for (var index = 1; index < arguments.length; index++) {\n    var source = arguments[index];\n\n    if (source !== undefined && source !== null) {\n      for (var nextKey in source) {\n        if (source.hasOwnProperty(nextKey)) {\n          output[nextKey] = source[nextKey];\n        }\n      }\n    }\n  }\n\n  return output;\n}\n\nexport default Carousel;","map":{"version":3,"sources":["/home/mindbox/Documents/manoj/nexus/src/components/Carousel/Carousel.js"],"names":["React","useState","useEffect","useRef","PropTypes","Index","styles","wrapper","width","height","position","frame","Carousel","Component","constructor","props","state","frames","concat","children","current","mounted","debounceTimeoutId","onTouchStart","bind","onTouchMove","onTouchEnd","onResize","autoSlide","prev","next","loop","auto","console","warn","componentDidMount","prepareAutoSlide","hideFrames","refs","addEventListener","capture","window","componentWillUnmount","clearAutoTimeout","removeEventListener","componentDidUpdate","_","prevState","length","getDerivedStateFromProps","nextProps","nextState","i","style","opacity","clearTimeout","setTimeout","updateFrameSize","prepareSiblingFrames","e","total","pageX","pageY","touches","setState","startX","startY","deltaX","deltaY","axis","Math","abs","preventDefault","stopPropagation","moveFramesBy","direction","decideEndPosition","transitFramesTowards","duration","minMove","movingFrames","frameWidth","frameHeight","translateXY","slideTimeoutID","interval","slider","rel","getClientRects","cb","getComputedStyle","parseFloat","split","getSiblingFrames","getFrameId","siblings","undefined","pos","onTransitionEnd","newCurrentId","render","widgets","wrapperStyle","objectAssign","IMG_WIDTH","IMG_HEIGHT","parentPad","VISIBLEIMAGES","DURATION","imgList","img_width","img_height","visibleImages","autoNext","timeForNext","currFirstImg","setCurrFirstImg","actualFirst","setActualFirst","visibleItemsProps","setVisibleItemsProps","order","currMiddleImgRef","intervalRef","imgDifference","durationRef","parentHeight","parentWidth","elementsInLeft","ceil","elementsInRight","constructVisibleItemsProps","curr_center","timesToIterate","zIndex","xTranslate","zTranslate","division","opacityDivider","rightEltCount","leftEltCount","curr_center_copy","currImgIndex","currImgIndexOnRight","nextIndex","transform","push","changeCenter","event","index","large_url","currFirstImgIndex","indexOf","prevIndex","val","cycleToNextImage","open","actual","clearInterval","setInterval","nextImg","overflow","className","map","frameStyle","Widget","propTypes","oneOf","bool","number","arrayOf","func","element","object","defaultProps","el","x","y","transitionDuration","webkitTransitionDuration","currentItem","webkitTransform","target","output","Object","arguments","source","nextKey","hasOwnProperty"],"mappings":"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","sourcesContent":["import React, {useState, useEffect, useRef} from 'react'\nimport PropTypes from 'prop-types'\nimport Index from './Index'\n\nconst styles = {\n  wrapper: {\n    width: '100%',\n    height: '100%',\n    position: 'relative'\n  },\n  frame: {\n    // width: '100%',\n    height: '100%',\n    position: 'absolute'\n  }\n}\n\nclass Carousel extends React.Component {\n  constructor (props) {\n    super(props)\n\n    this.state = {\n      frames: [].concat(props.frames || props.children || []),\n      current: 0\n    }\n\n    this.mounted = false\n    this.debounceTimeoutId = null\n    this.onTouchStart = this.onTouchStart.bind(this)\n    this.onTouchMove = this.onTouchMove.bind(this)\n    this.onTouchEnd = this.onTouchEnd.bind(this)\n    this.onResize = this.onResize.bind(this)\n    this.autoSlide = this.autoSlide.bind(this)\n    this.prev = this.prev.bind(this)\n    this.next = this.next.bind(this)\n\n    if (props.loop === false && props.auto) {\n      console.warn('[re-carousel] Auto-slide only works in loop mode.')\n    }\n  }\n\n  componentDidMount () {\n    this.mounted = true\n    this.prepareAutoSlide()\n    this.hideFrames()\n\n    this.refs.wrapper.addEventListener('touchmove', this.onTouchMove, {capture: true})\n    this.refs.wrapper.addEventListener('touchend', this.onTouchEnd, {capture: true})\n    window.addEventListener('resize', this.onResize);\n  }\n\n  componentWillUnmount () {\n    this.mounted = false\n    this.clearAutoTimeout()\n\n    this.refs.wrapper.removeEventListener('touchmove', this.onTouchMove, {capture: true})\n    this.refs.wrapper.removeEventListener('touchend', this.onTouchEnd, {capture: true})\n    window.removeEventListener('resize', this.onResize);\n  }\n\n  componentDidUpdate(_, prevState) {\n    if (this.state.frames.length && this.state.frames.length !== prevState.frames.length) {\n      // reset to default state\n      this.hideFrames()\n      this.prepareAutoSlide()\n    }\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    const frames = [].concat(nextProps.frames || nextProps.children || [])\n    const nextState = { frames }\n    if (frames.length && frames.length !== prevState.frames.length) {\n      nextState.current = 0\n    }\n    return nextState\n  }\n\n  hideFrames () {\n    for (let i = 1; i < this.state.frames.length; i++) {\n      this.refs['f' + i].style.opacity = 0\n    }\n  }\n\n  onResize() {\n    clearTimeout(this.debounceTimeoutId);\n    this.debounceTimeoutId = setTimeout(() => {\n      this.updateFrameSize(() => {\n        this.prepareSiblingFrames();\n      });\n    }, 25);\n  }\n\n  onTouchStart (e) {\n    if (this.state.total < 2) return\n    // e.preventDefault()\n\n    this.clearAutoTimeout()\n    this.updateFrameSize()\n    this.prepareSiblingFrames()\n\n    const { pageX, pageY } = (e.touches && e.touches[0]) || e\n    this.setState({\n      startX: pageX,\n      startY: pageY,\n      deltaX: 0,\n      deltaY: 0\n    })\n\n    this.refs.wrapper.addEventListener('mousemove', this.onTouchMove, {capture: true})\n    this.refs.wrapper.addEventListener('mouseup', this.onTouchEnd, {capture: true})\n    this.refs.wrapper.addEventListener('mouseleave', this.onTouchEnd, {capture: true})\n  }\n\n  onTouchMove (e) {\n    if (e.touches && e.touches.length > 1) return\n    this.clearAutoTimeout()\n\n    const { pageX, pageY } = (e.touches && e.touches[0]) || e\n    let deltaX = pageX - this.state.startX\n    let deltaY = pageY - this.state.startY\n    this.setState({\n      deltaX: deltaX,\n      deltaY: deltaY\n    })\n\n    if (this.props.axis === 'x' && Math.abs(deltaX) > Math.abs(deltaY)) {\n      e.preventDefault()\n      e.stopPropagation()\n    }\n    if (this.props.axis === 'y' && Math.abs(deltaY) > Math.abs(deltaX)) {\n      e.preventDefault()\n      e.stopPropagation()\n    }\n\n    // when reach frames edge in non-loop mode, reduce drag effect.\n    if (!this.props.loop) {\n      if (this.state.current === this.state.frames.length - 1) {\n        deltaX < 0 && (deltaX /= 3)\n        deltaY < 0 && (deltaY /= 3)\n      }\n      if (this.state.current === 0) {\n        deltaX > 0 && (deltaX /= 3)\n        deltaY > 0 && (deltaY /= 3)\n      }\n    }\n\n    this.moveFramesBy(deltaX, deltaY)\n  }\n\n  onTouchEnd () {\n    const direction = this.decideEndPosition()\n    direction && this.transitFramesTowards(direction)\n\n    // cleanup\n    this.refs.wrapper.removeEventListener('mousemove', this.onTouchMove, {capture: true})\n    this.refs.wrapper.removeEventListener('mouseup', this.onTouchEnd, {capture: true})\n    this.refs.wrapper.removeEventListener('mouseleave', this.onTouchEnd, {capture: true})\n\n    setTimeout(() => this.prepareAutoSlide(), this.props.duration)\n  }\n\n  decideEndPosition () {\n    const { deltaX = 0, deltaY = 0, current, frames } = this.state\n    const { axis, loop, minMove } = this.props\n\n    switch (axis) {\n      case 'x':\n        if (loop === false) {\n          if (current === 0 && deltaX > 0) return 'origin'\n          if (current === frames.length - 1 && deltaX < 0) return 'origin'\n        }\n        if (Math.abs(deltaX) < minMove) return 'origin'\n        return deltaX > 0 ? 'right' : 'left'\n      case 'y':\n        if (loop === false) {\n          if (current === 0 && deltaY > 0) return 'origin'\n          if (current === frames.length - 1 && deltaY < 0) return 'origin'\n        }\n        if (Math.abs(deltaY) < minMove) return 'origin'\n        return deltaY > 0 ? 'down' : 'up'\n      default:\n    }\n  }\n\n  moveFramesBy (deltaX, deltaY) {\n    const { prev, current, next } = this.state.movingFrames\n    const { frameWidth, frameHeight } = this.state\n\n    switch (this.props.axis) {\n      case 'x':\n        translateXY(current, deltaX, 0)\n        if (deltaX < 0) {\n          translateXY(next, deltaX + frameWidth, 0)\n        } else {\n          translateXY(prev, deltaX - frameWidth, 0)\n        }\n        break\n      case 'y':\n        translateXY(current, 0, deltaY)\n        if (deltaY < 0) {\n          translateXY(next, 0, deltaY + frameHeight)\n        } else {\n          translateXY(prev, 0, deltaY - frameHeight)\n        }\n        break\n      default:\n    }\n  }\n\n  prepareAutoSlide () {\n    if (this.state.frames.length < 2) return\n\n    this.clearAutoTimeout()\n    this.updateFrameSize(() => {\n      this.prepareSiblingFrames()\n    })\n\n    // auto slide only avalible in loop mode\n    if (this.mounted && this.props.loop && this.props.auto) {\n      const slideTimeoutID = setTimeout(this.autoSlide, this.props.interval)\n      this.setState({ slider: slideTimeoutID })\n    }\n  }\n\n  // auto slide to 'next' or 'prev'\n  autoSlide (rel) {\n    this.clearAutoTimeout()\n\n    switch (rel) {\n      case 'prev':\n        this.transitFramesTowards(this.props.axis === 'x' ? 'right' : 'down')\n        break\n      case 'next':\n      default:\n        this.transitFramesTowards(this.props.axis === 'x' ? 'left' : 'up')\n    }\n\n    // prepare next move after animation\n    setTimeout(() => this.prepareAutoSlide(), this.props.duration)\n  }\n\n  next () {\n    const { current, frames } = this.state\n    if (!this.props.loop && current === frames.length - 1) return false\n    this.autoSlide('next')\n  }\n\n  prev () {\n    if (!this.props.loop && this.state.current === 0) return false\n    const { prev, next } = this.state.movingFrames\n\n    if (prev === next) {\n      // Reprepare start position of prev frame\n      // (it was positioned as \"next\" frame)\n      if (this.props.axis === 'x') {\n        translateXY(prev, -this.state.frameWidth, 0, 0)\n      } else {\n        translateXY(prev, 0, -this.state.frameHeight, 0)\n      }\n      prev.getClientRects() // trigger layout\n    }\n\n    this.autoSlide('prev')\n  }\n\n  clearAutoTimeout () {\n    clearTimeout(this.state.slider)\n  }\n\n  updateFrameSize (cb) {\n    const { width, height } = window.getComputedStyle(this.refs.wrapper)\n    this.setState({\n      frameWidth: parseFloat(width.split('%')[0]),\n      frameHeight: parseFloat(height.split('%')[0])\n    }, cb)\n  }\n\n  getSiblingFrames () {\n    return {\n      current: this.refs['f' + this.getFrameId()],\n      prev: this.refs['f' + this.getFrameId('prev')],\n      next: this.refs['f' + this.getFrameId('next')]\n    }\n  }\n\n  prepareSiblingFrames () {\n    const siblings = this.getSiblingFrames()\n\n    if (!this.props.loop) {\n      this.state.current === 0 && (siblings.prev = undefined)\n      this.state.current === this.state.frames.length - 1 && (siblings.next = undefined)\n    }\n\n    this.setState({ movingFrames: siblings })\n\n    // prepare frames position\n    translateXY(siblings.current, 0, 0)\n    if (this.props.axis === 'x') {\n      translateXY(siblings.prev, -this.state.frameWidth, 0)\n      translateXY(siblings.next, this.state.frameWidth, 0)\n    } else {\n      translateXY(siblings.prev, 0, -this.state.frameHeight)\n      translateXY(siblings.next, 0, this.state.frameHeight)\n    }\n\n    return siblings\n  }\n\n  getFrameId (pos) {\n    const { frames, current } = this.state\n    const total = frames.length\n    switch (pos) {\n      case 'prev':\n        return (current - 1 + total) % total\n      case 'next':\n        return (current + 1) % total\n      default:\n        return current\n    }\n  }\n\n  transitFramesTowards (direction) {\n    const { prev, current, next } = this.state.movingFrames\n    const { duration, axis, onTransitionEnd } = this.props\n\n    let newCurrentId = this.state.current\n    switch (direction) {\n      case 'up':\n        translateXY(current, 0, -this.state.frameHeight, duration)\n        translateXY(next, 0, 0, duration)\n        newCurrentId = this.getFrameId('next')\n        break\n      case 'down':\n        translateXY(current, 0, this.state.frameHeight, duration)\n        translateXY(prev, 0, 0, duration)\n        newCurrentId = this.getFrameId('prev')\n        break\n      case 'left':\n        translateXY(current, -this.state.frameWidth, 0, duration)\n        translateXY(next, 0, 0, duration)\n        newCurrentId = this.getFrameId('next')\n        break\n      case 'right':\n        translateXY(current, this.state.frameWidth, 0, duration)\n        translateXY(prev, 0, 0, duration)\n        newCurrentId = this.getFrameId('prev')\n        break\n      default: // back to origin\n        translateXY(current, 0, 0, duration)\n        if (axis === 'x') {\n          translateXY(prev, -this.state.frameWidth, 0, duration)\n          translateXY(next, this.state.frameWidth, 0, duration)\n        } else if (axis === 'y') {\n          translateXY(prev, 0, -this.state.frameHeight, duration)\n          translateXY(next, 0, this.state.frameHeight, duration)\n        }\n    }\n\n    onTransitionEnd && setTimeout(() => onTransitionEnd(this.getSiblingFrames()), duration)\n\n    this.setState({ current: newCurrentId })\n  }\n\n  // debugFrames () {\n  //   console.log('>>> DEBUG-FRAMES: current', this.state.current)\n  //   const len = this.state.frames.length\n  //   for (let i = 0; i < len; ++i) {\n  //     const ref = this.refs['f' + i]\n  //     console.info(ref.innerText.trim(), ref.style.transform)\n  //   }\n  // }\n\n  render () {\n    const { frames, current } = this.state\n    const { widgets, axis, loop, auto, interval } = this.props\n    const wrapperStyle = objectAssign(styles.wrapper, this.props.style)\n    /* Default Properties */\n    const IMG_WIDTH = 300;\n    const IMG_HEIGHT = 300;\n    const parentPad = 0;\n    const VISIBLEIMAGES = 3;\n    const DURATION = 750;\n    const {imgList = [], img_width = IMG_WIDTH, img_height = IMG_HEIGHT, visibleImages = VISIBLEIMAGES, duration = DURATION, autoNext = false, timeForNext = 5000} = this.props;\n    /* Hooks Declarations Start*/\n    const [currFirstImg, setCurrFirstImg] = useState(0);  // The Current Middle Element/Primary element of our carousel\n    const [actualFirst, setActualFirst] = useState('');   // The Clicked Image when it is not the Immediate Next or Immediate Previous Image\n    const [visibleItemsProps, setVisibleItemsProps] = useState({ order: [], styles: {}}); // Set Styles and ordering to Images currently visible\n    const currMiddleImgRef = useRef(0);  // Reference for the image that is in the middle\n    const intervalRef = useRef(0);  // Reference to interval so that it can be removed from within/ before initiating new interval\n    const imgDifference = useRef(1); // The difference between the middle image and the image that is clicked by user to view next\n    const durationRef = useRef(duration); // Animation Duration, it should be changed when the image cicked is not immediate next/prev\n    /* Hooks Declarations End*/\n    const parentHeight = img_height + 2 * parentPad;  // To avoid overlap with Carousel Component's siblings, since all images are absolutely positioned\n    const parentWidth = img_width * 3;  // To have thrice the width of an individual image\n    const elementsInLeft = Math.ceil(visibleImages / 2);  // Floor is done to also include middle image along with other images to its left.\n    const elementsInRight = visibleImages - elementsInLeft;\n\n    const constructVisibleItemsProps = () => {\n      const visibleItemsProps = {}; // To store config for items that are visibile in the carousel\n      visibleItemsProps.order = [];\n      let curr_center = currFirstImg; // Storing the Current Middle element in focus\n      let timesToIterate = 0; // To iterate through all visible number of images.\n      let zIndex = - elementsInRight; // We start from left to right and Zindex has to keep on increasing till middle then has to reduce.\n      let xTranslate = img_width; // To move the element with respect to x axis\n      let zTranslate = 0; // To reduce image size for images apart from center\n      let opacity = 1;\n      const division = (img_width * (1.66 / elementsInLeft)); // Specifies the length that next image has to move away from with resoect to current image (1.6 times the current image)\n      let opacityDivider = (0.7 / elementsInRight); // minimum opacity should be 0.3 (1-0.7)\n      let rightEltCount = elementsInRight;\n      let leftEltCount = elementsInLeft; // including middle element\n      let curr_center_copy = curr_center;\n    \n      while(timesToIterate < visibleImages ) {\n        const styles = {};\n        let currImgIndex;\n        let currImgIndexOnRight = true; // Tells if in this iteration the currently iterated image lies left to the middle image or not\n        // To set properties for elements in right side\n        if (timesToIterate < elementsInRight) {\n          const nextIndex = curr_center - (rightEltCount);\n          currImgIndex = nextIndex > -1 ? nextIndex : imgList.length - Math.abs(nextIndex); // Gives the rightmost elemnt in first iteration and then the subsequent elements down the iteration\n          opacity = 1 - (opacityDivider * rightEltCount); // To assign lowest opacity to last element and increaing it till we come to middle\n          zTranslate =  -division * rightEltCount;  // To increase the size of the images subsequently from last to middle\n          xTranslate = img_width - (division * rightEltCount);  // X coordinate position\n          rightEltCount--;\n        } else {  // To set properties for elements in center and to left of it. All props behaves similar to right\n          currImgIndexOnRight = false;\n          currImgIndex = curr_center_copy;  \n          if (curr_center_copy + 1 >= imgList.length) { // to maintain cyclic carousel\n            curr_center_copy = 0;\n          } else {\n            curr_center_copy++;\n          }\n          opacity = 1 - (opacityDivider * Math.abs(leftEltCount - (timesToIterate + 1)));\n          zTranslate =  - division * Math.abs(leftEltCount - (timesToIterate + 1));\n          xTranslate = img_width + division * Math.abs(leftEltCount - (timesToIterate + 1));\n        }\n        // Assigning above calculated values to 'styles' object\n        styles.transform =  'translateX(' + xTranslate + 'px) translateZ(' +  zTranslate + 'px)';\n        styles.opacity = opacity;\n        styles.zIndex = currImgIndexOnRight ? zIndex++ : zIndex --; // To reduce zIndex while going through left elements\n        visibleItemsProps.order.push(currImgIndex); // Push the current image number in the orders array\n        visibleItemsProps[currImgIndex] = { styles }; // pushing all previously created styles\n        timesToIterate++;\n      }\n      durationRef.current = actualFirst === '' ? duration : ((duration / imgDifference.current)); // duration will be user given if he clicks next image or we divide the duration by number of images skipped\n      setVisibleItemsProps(visibleItemsProps); // setting state for visible items\n    }\n\n\n    const changeCenter = ({event, index, large_url }) => {\n      // Checking if the clicked item is immediately next/prev item.Because to induce a carousel effect we need to make the images move in sequence.\n      // But that is not possible, when the user clicks out of sequence(Eg: image 4 from image 1).So here, the order breaks and we cannot \n      // apply our sequential handling logic to it. If we do the 4th image comes into view from the back but the \"cycling effect\"\n      // of scrolling through images 2 and 3 would have been missed.\n      const currFirstImgIndex = visibleItemsProps.order.indexOf(currFirstImg);\n      const prevIndex = visibleItemsProps.order[currFirstImgIndex - 1];\n      const nextIndex = visibleItemsProps.order[currFirstImgIndex + 1];\n      if (index !== currFirstImg) {\n        if (index === prevIndex || index === nextIndex) { // if immediate first/next image\n          setCurrFirstImg(index);\n        } else {\n          const val = currFirstImgIndex - visibleItemsProps.order.indexOf(index);\n          imgDifference.current = Math.abs(val);  // Gives the number of images we have to cycle through, so we can provide equal part of total duration to all images.\n          setActualFirst(index);\n          cycleToNextImage(index);\n        }\n      } else {\n        window.open(large_url); // Can have a callback in props and execute it on click.\n      }\n    }\n\n    // To show the subsequent image based on if the user has clicked on the right side or on the left side of the middle image\n    const cycleToNextImage = (actual) => {\n      if (visibleItemsProps.order.indexOf(currMiddleImgRef.current) > visibleItemsProps.order.indexOf(actual)) {  // Right side image click\n        currMiddleImgRef.current = currMiddleImgRef.current - 1 > -1 ? currMiddleImgRef.current - 1 : imgList.length - 1; // Right side image click\n        setCurrFirstImg(currMiddleImgRef.current);\n      } else {  // Left side image click\n        currMiddleImgRef.current = (currMiddleImgRef.current + 1) < imgList.length ?  (currMiddleImgRef.current + 1) : 0; // Conditions to handle cycle\n        setCurrFirstImg(currMiddleImgRef.current);\n      }\n    }\n\n    // Hook fires on evey change to actualFirst value. actualFirst is set when there is out of order click, so we have to handle it through timeinterval\n    // so that we can allow all intermediate images to do some animation in the meantime, to avoid the cycling look jerky.\n    useEffect(() => {\n      clearInterval(intervalRef.current);\n      if (actualFirst !== '') {\n        intervalRef.current = setInterval(() => {\n          if (actualFirst !== '' && actualFirst !== currMiddleImgRef.current) { // If the currentimage in middle is not actually clicked image then gotoNext image\n            cycleToNextImage(actualFirst);\n          } else if (actualFirst !== '' && actualFirst === currMiddleImgRef.current){\n            setActualFirst('');\n            imgDifference.current = 1;\n            clearInterval(intervalRef.current); // If actual clicked and middle image are same we are all set to clear intervals, as they are unnecessary now\n          }\n        }, durationRef.current - 100);  // Introduced an advance of 100ms to begin bringing nextimage to middle before the previous one settles down else it looks jerky\n      }\n    }, [actualFirst]);\n\n\n    useEffect(() => {\n      constructVisibleItemsProps(); // This constructs all css properties to the elements in visibility\n      currMiddleImgRef.current = currFirstImg;  // Need to set it here as well so while accessing inside interval it will have the latest value\n    }, [currFirstImg]);\n\n    useEffect(() => {\n      if (autoNext) {\n        setInterval(() => {\n          const nextImg = currMiddleImgRef.current + 1 < imgList.length ?  currMiddleImgRef.current + 1 : 0;\n          setCurrFirstImg(nextImg);\n        }, timeForNext);\n      }\n    }, []);\n\n    return (\n      <div style={wrapperStyle}>\n        <div \n          ref='wrapper'\n          style={objectAssign({overflow: 'hidden'}, wrapperStyle)}\n          onTouchStart={this.onTouchStart}\n          className={this.props.className}\n          onMouseDown={this.onTouchStart} >\n          {\n            frames.map((frame, i) => {\n              const frameStyle = objectAssign({zIndex: 99 - i}, styles.frame)\n              return <div ref={'f' + i} key={i} style={frameStyle} className={`${current === i ? 'current slide' : 'slide'}`}>{frame}</div>\n            })\n          }\n          { this.props.frames && this.props.children }\n        </div>\n        {\n          widgets && [].concat(widgets).map((Widget, i) => (\n            <Widget\n              key={i}\n              index={current}\n              total={frames.length}\n              prevHandler={this.prev}\n              nextHandler={this.next}\n              axis={axis} loop={loop} auto={auto} interval={interval} />\n          ))\n        }\n      </div>\n    )\n  }\n}\n\nCarousel.propTypes = {\n  axis: PropTypes.oneOf(['x', 'y']),\n  auto: PropTypes.bool,\n  loop: PropTypes.bool,\n  interval: PropTypes.number,\n  duration: PropTypes.number,\n  widgets: PropTypes.arrayOf(PropTypes.func),\n  frames: PropTypes.arrayOf(PropTypes.element),\n  style: PropTypes.object,\n  minMove: PropTypes.number,\n  onTransitionEnd: PropTypes.func\n}\n\nCarousel.defaultProps = {\n  axis: 'x',\n  auto: false,\n  loop: false,\n  interval: 5000,\n  duration: 300,\n  minMove: 42\n}\n\nfunction translateXY (el, x, y, duration = 0) {\n  if (!el) return\n\n  el.style.opacity = '1'\n\n  // animation\n  el.style.transitionDuration = duration + 'ms'\n  el.style.webkitTransitionDuration = duration + 'ms'\n  el.currentItem = `translate(${x}px, ${y}px)`\n  el.style.transform = `translate(${x}px, ${y}px)`\n  el.style.webkitTransform = `translate(${x}px, ${y}px) translateZ(0)`\n}\n\nfunction objectAssign (target) {\n  var output = Object(target)\n  for (var index = 1; index < arguments.length; index++) {\n    var source = arguments[index]\n    if (source !== undefined && source !== null) {\n      for (var nextKey in source) {\n        if (source.hasOwnProperty(nextKey)) {\n          output[nextKey] = source[nextKey]\n        }\n      }\n    }\n  }\n  return output\n}\n\nexport default Carousel"]},"metadata":{},"sourceType":"module"}